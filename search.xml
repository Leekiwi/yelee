<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你不知道的vue技巧]]></title>
    <url>%2F2018%2F11%2F10%2Fvue%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E4%B8%8E%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.setTimeout/ setInterval 场景一: this 指向改变无法用 this 访问 vue 实例 1234567891011 mounted()&#123; setTimeout( function () &#123; //setInterval同理 console.log(this); //此时this指向Window对象 &#125;，1000) ;&#125; 解决方法 :使用箭头函数或者缓存 this 123456789101112131415 //箭头函数访问this实例因为箭头函数本身没有绑定thissetTimeout(() =&gt; &#123; console. log(this);&#125;, 500) ; //使用变量访问this实例let self=this;&#125;,1000);setTimeout (function () &#123; console. log(self);//使用self变量访问this实例&#125;, 1000) ; setInterval 路由跳转继续运行并没有销毁 场景一 :比如一些弹幕，走马灯文字，这类需要定时调用的，路由跳转之后，因为组件已经销毁了，但是setlnterval还没有销毁，还在继续后台调用，控制台会不断报错，如果运算量大的话，无法及时清除，会导致严重的页面卡顿。 解决方法 :在组件生命周期beforeDestroy停止setInterval 1234567891011 created() &#123; this.intervalid = setInterval(() =&gt; &#123; this.layerError = ""; this.Timer = null; &#125;, 100000); &#125; beforeDestroy( )&#123; //我通常是把setInterval( )定时器赋值给this实例，然后就可以像下面这么暂停。 clearInterval(this.intervalid); &#125;` 2.Vue路由拦截浏览器后退实现草稿保存类似需求 场景一 :为了防止用户突然离开，没有保存已输入的信息。 解决方法 : 12345678//在路由组件中:mounted()&#123;&#125;，beforeRouteLeave (to, from, next) &#123; if(用户已经输入信息)&#123; //出现弹窗提醒保存草稿，或者自动后台为其保存 &#125;else&#123; next(true);//用户离开 &#125;&#125; 3.自定义组件添加click等事件不生效 场景一 :一些自定义组件，需要额外添加一些事件来实现一些特定需求 123456789101112&lt;template&gt; &lt;el-progress type="circle" :percentage=“0" [@click](/user/click)=“stopProgress”&gt;&lt;/elprogress&gt; &lt;/template&gt; &lt;script&gt; export default &#123; methods:&#123; stopProgress() &#123; console.log('停止') &#125; &#125; &#125; &lt;/script&gt; 解决方法:使用.native修饰符 123456789101112&lt;template&gt; &lt;el-progress type="circle" :percentage=“0" [@click](/user/click).native=“stopProgress”&gt;&lt;/el-progress&gt;&lt;/template&gt; &lt;script&gt; export default &#123; methods:&#123; stopProgress() &#123; console.log('停止') &#125; &#125; &#125; &lt;/script&gt; 4.手动操控自定义组件 场景一 :一些自定义组件，需要去获取组件对象进行一些其他的Dom操作 解决方法 :使用ref属性暴露组件获取句柄 123456&lt;template&gt; &lt;el-progress type="circle" :percentage="O" ref="progress"&gt;&lt;/el-progress&gt;&lt;/template&gt;&lt;script&gt; this.$refs.progress //组件对象实例， 可以手动调用组件的内置方法和属性 this.$refs.progress.$el //组件 对象的最外层dom元素&lt;/script&gt; 5.深度作用选择器 场景一 : scoped的样式，希望影响到子组件的默认样式 在样式中设置完scoped在浏览器解析为如下图这样，a是个div，a div里面包含一个组件里面解析完了div的样式名字为b，想在父组件影响到子组件的默认样式。解决方法: 123456 &lt;style scoped&gt; .a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt; //有些像Sass之类的预处理器无法正确解析&gt;&gt;&gt;。这种情况下你可以使用/deep/操作符取而代之- - - -这是一个&gt;&gt;&gt;的别名，同样可以正常工作。 &lt;style scoped lang=“scss”&gt; .a /deep/ .b &#123; /* ... */ &#125;&lt;/style&gt; 6.Vue数组/对象更新视图不更新 场景一 :很多时候我们习惯于这样操作数组和对象 1234567891011121314151617 data() &#123; return &#123; arr: [1,2,3], obj:&#123; a: 1, b: 2 &#125; &#125;; &#125;,// 数组更新视图不更新this.arr[0] = ‘OBKoro1’;this.arr.length = 1;console.log(arr);// [‘OBKoro1’];// 数据更新，对象视图不更新this.obj.c = ‘OBKoro1’;delete this.obj.a;console.log(obj); // &#123;b:2,c:’OBKoro1’&#125; 解决方法 ： this. $set(你要改变的数组/对象，你要改变的位置/key,你要改成什么value) 数组原生方法触发视图更新（ vue官网可查）: 整体替换数组/对象 7.Vue Filters过滤器的使用 场景一 :常见的数据文本的格式化123456789101112131415161718192021 &lt;!– 在双花括号中 –&gt;&lt;div&gt;&#123;&#123; message | DateFormat &#125;&#125;&lt;/div&gt; //展示正确时间&lt;!– 在‘v-bind’中 –&gt;&lt;div v-bind:id=“rawId | formatId”&gt;&lt;/div&gt;Demo:一个日期过滤器返回yyyy- MM-ddhh:mm:ss的样式引入一个提前写好日期格式化的js import dayjs from ‘dayjs’;export default &#123; data() &#123; return &#123; //时间毫秒 message:18324798324789 &#125; &#125;, filters: &#123; //传入进行日期格式化 DateFormat(value) &#123; return dayjs(value).format(“YYYY-MM-DD HH:mm:ss") &#125; &#125;&#125; 8.Vue深度watch与watch立即触发回调 场景一 :在watch里面监测对象里面对应的值是监测不到的，可以用如下方法。 选项: deep 在选项参数中指定deep:true,可以监听对象中子属性的变化。 选项: immediate 在选项参数中指定immediate:true,将立即以表达式的当前值触发回调，也就是默认触发一次。 1234567891011121314 watch: &#123; obj: &#123; handler(val, oldVal) &#123; console.log(‘属性变化触发这个回调’,val, oldVal); &#125;, deep: true // 监测这个对象中每一个属性的变化 &#125;, step: &#123; // 属性 //watch handler(val, oldVal) &#123; console.log(“默认触发一次”, val, oldVal); &#125;, immediate: true // 默认触发一次 &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>college</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebGL获取Context时的附加参数]]></title>
    <url>%2F2018%2F11%2F08%2FWebGL%E8%8E%B7%E5%8F%96Context%E6%97%B6%E7%9A%84%E9%99%84%E5%8A%A0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最近在研究 WebGL 渲染，本想用模板缓冲实现类似 Canvas2d 上的 clip()接口，绘制时裁切指定范围。可是发现无论怎么设置模板缓冲都没法正确显示。最后谷歌了一下才发现只设置gl.enable(gl.STENCIL_TEST)是不够的，在获取 WebGL 的 context 时还需要额外设置参数才能开启模板缓冲功能： 1var gl = canvas.getContext("webgl",&#123;stencil:true&#125;); 有这么个额外参数，而且是传入 Object，那同理是不是还应该有其他的未知参数？可是各种书上都没找到有介绍这些额外参数的。最后在 MDN 的文档里找到了：HTMLCanvasElement.getContext() 其中列举了如下参数： alpha: 指示 Canvas 是否含有透明通道，若设置为 false 不透明，如果 Canvas 下叠加了其他元素时，可以在绘制时提升一些性能 antialias: 绘制时是否开启抗锯齿功能 depth: 是否开启深度缓冲功能 failIfMajorPerformanceCaveat: true 表示当系统性能较低时，将不允许创建 context。也就是是 getContext()返回 null。 premultipliedAlpha: 这个功能做图形渲染的应该很熟悉，将 alpha 通道预先乘入 rgb 通道内，以提高合成性能，一两句话说不清，具体自己谷歌一下吧。 preserveDrawingBuffer: 是否保留缓冲区数据，如果你需要读取像素，或者复用绘制到主屏幕上的图像（实现脏矩形局部刷新），需要开启这个，否则浏览器在发生新的绘制操作的时候，有可能清空以前的数据。 stencil: 是否开启模板缓冲功能 另外，WebGLRenderingContext上还有个getContextAttributes()方法,用这个方法能够获取当前 context 上的所有附加属性状态值。我用这个方法在 chrome 上输出了这些属性的默认值如下： alpha: true antialias: true depth: true failIfMajorPerformanceCaveat: false premultipliedAlpha: true preserveDrawingBuffer: false stencil: false 可以看到我们的模板缓冲 stencil 功能果然是默认 false 关闭的。最后，stackoverflow 上说，getContextAttributes()还有个其他作用，因为 getContext()方法你传递 stencil 为 true 进去，浏览器并不一定会就给你开启 stencil，要检查当前 stencil 是否开启，还要用getContextAttributes()获取属性对象，检查一下上面的属性是否为 true。]]></content>
      <tags>
        <tag>图形渲染</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用canvas的toDataURL()将图片转为dataURL(base64)]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%94%A8canvas%E7%9A%84toDataURL()%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BAdataURL(base64)%2F</url>
    <content type="text"><![CDATA[假设一个应用场景：由于某些特殊原因从服务端请求到图片路径，要求通过该路径获取对应图片的 base64 dataURL。在这个场景中，我们首先推断该图片路径是可访问的，同时还需要一种将图片转换到 dataURL 的方法。我们如何实现它呢？ dataURL先大致回顾下正统的 dataURL 的语法，这有助于我们检验转换后的内容是否正确。一个完整的 dataURI 应该是这样的： 1data:[&lt;mediatype&gt;][;base64],&lt;data&gt; 其中 mediatype 声明了文件类型，遵循 MIME 规则，如“image/png”、“text/plain”；之后是编码类型，这里我们只涉及 base64；紧接着就是文件编码后的内容了。我们常常在 HTML 里看到 img 标签的 src 会这样写： 1src="data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7" 这个 img引用的就是以 base64 编码的 dataURL 了，只要浏览器支持，就可以被解码成声明格式的图片并渲染出来。 .toDataURL()这是一个功能函数，FileReader 对象也有类似的方法，比如.readAsDataURL()，然而它只接受 file 或 blob 类型，而这两种类型一般只能通过&lt;input[type=file]&gt;元素的 files 属性获取，或者用 Blob()构造函数手工创建一个新的对象。尴尬的是我们当前只有图片路径，受制于浏览器的安全策略，&lt;input[type=file]&gt;的 files 属性是只读的，而 Blob()构造函数只接受文件内容，两种方式都无法通过图片路径直接获取。上文中假设的应用场景迫使我们必先考虑如何通过路径获取到图片内容。&lt;img&gt;是可以的，并且可以被绘制到&lt;canvas&gt;中，而&lt;canvas&gt;正巧拥有.toDataURL()方法。 万事具备，我们只需要把&lt;img&gt;获取到的图片放到&lt;canvas&gt;里再通过.toDataURL()方法转化下，就可以得到以 base64 编码的 dataURL。来看这个方法的语法： 1canvas.toDataURL([type, encoderOptions]); canvas 是 DOM 元素&lt;canvas&gt;对象；参数 type 指定图片类型，如果指定的类型不被支持则以默认值 image/png 替代；encoderOptions 可以为 image/jpeg 或 image/webp 类型的图片设置图片质量，取值 0-1，超出则以默认值 0.92 替代。 需要注意的是，图片加载是异步的，在转换成 dataURL 前必须先确保图片成功加载到，否则让 canvas 即刻执行绘制可能失败，从而导致转换 dataURL 失败。于是.toDataURL()方法应该写在&lt;img&gt;的 onload 事件中，以确保 canvas 的绘制工作在图片下载完成后开始。好在.drawImage()方法是同步的，只有在 canvas 绘制完成后才会执行后续操作，比如.toDataURL()。现在就来实现一个功能函数： 123456789101112131415function getBase64(url)&#123; //通过构造函数来创建的 img 实例，在赋予 src 值后就会立刻下载图片，相比 createElement() 创建 &lt;img&gt; 省去了 append()，也就避免了文档冗余和污染 var Img = new Image(), dataURL=''; Img.src=url; Img.onload=function()&#123; //要先确保图片完整获取到，这是个异步事件 var canvas = document.createElement("canvas"), //创建canvas元素 width=Img.width, //确保canvas的尺寸和图片一样 height=Img.height; canvas.width=width; canvas.height=height; canvas.getContext("2d").drawImage(Img,0,0,width,height); //将图片绘制到canvas中 dataURL=canvas.toDataURL('image/jpeg'); //转换图片为dataURL &#125;;&#125; 一个可供随时调用的转换函数完成了，它会在图片被加载后返回一整个 dataURL 字符串。 完善onload 事件确保了转换任务在图片加载后执行，却又带来了新问题——dataURL 只有在图片加载完成后才会返回，我们无法精准得到图片完成加载的时长。如果后续要对 dataURL 做相关处理（比如传递到其他服务器）的话，添加一个回调是必要的，这能确保后续处理任务在成功得到 dataURL 之后执行，我们修改一下 getBase64()： 123456789101112131415function getBase64(url,callback)&#123; //添加一个回调参数 var Img = new Image(), dataURL=''; Img.src=url; Img.onload=function()&#123; var canvas = document.createElement("canvas"), //创建canvas元素 width=Img.width, //确保canvas的尺寸和图片一样 height=Img.height; canvas.width=width; canvas.height=height; canvas.getContext("2d").drawImage(Img,0,0,width,height); dataURL=canvas.toDataURL('image/jpeg'); callback?callback(dataURL):null; //调用回调函数 &#125;;&#125; 在执行时添加回调： 123getBase64('//upload.jianshu.io/users/upload_avatars/555630/fdd1b798e6b0.jpg',(dataURL)=&gt;&#123; console.log(dataURL);&#125;); 就是这样。如果不考虑兼容性的话，或许我们可以用 promise 和 generator 来实现，再添加一些错误处理就更完美了。]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>college</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas API学习小记]]></title>
    <url>%2F2018%2F11%2F01%2Fcanvas%2F</url>
    <content type="text"><![CDATA[Canvas API 详解Canvas API概述 Canvas API（画布）用于在网页实时生成图像，并且可以操作图像内容，基本上它是一个可以用 JavaScript 操作的位图（bitmap）。 开始使用 一、首先新建一个网页元素。 123&lt;canvas id="myCanvas" width="400" height="200"&gt;你的浏览器不支持 canvas!&lt;/canvas&gt; 上面代码中，如果浏览器不支持这个 API，则就会显示&lt;canvas&gt;标签中间的文字——“您 de 浏览器不支持 canvas！”。 每个 canvas 节点都有一个对应的 context 对象（上下文对象），Canvas API 定义在这个 context 对象上面，所以需要获取这个对象，方法是使用 getContext 方法。 12345var canvas = document.getElementById('myCanvas');if (canvas.getContext) &#123;var ctx = canvas.getContext('2d');&#125; 上面代码中，getContext 方法指定参数 2d，表示该 canvas 节点用于生成 2D 图案（即平面图案）。如果参数是 webgl，就表示用于生成 3D 图像（即立体图案），这部分实际上单独叫做 WebGL API。 绘图方法canvas 画布提供了一个用来作图的平面空间，该空间的每个点都有自己的坐标，x 表示横坐标，y 表示竖坐标。原点(0, 0)位于图像左上角，x 轴的正向是原点向右，y 轴的正向是原点向下 （1）绘制路径beginPath 方法表示开始绘制路径，moveTo(x, y)方法设置线段的起点，lineTo(x, y)方法设置线段的终点，stroke 方法用来给透明的线段着色。 123456ctx.beginPath(); // 开始路径绘制ctx.moveTo(20, 20); // 设置路径起点，坐标为(20,20)ctx.lineTo(200, 20); // 绘制一条到(200,20)的直线ctx.lineWidth = 1.0; // 设置线宽ctx.strokeStyle = '#CC0000'; // 设置线的颜色ctx.stroke(); // 进行线的着色，这时整条线才变得可见 moveto 和 lineto 方法可以多次使用。最后，还可以使用 closePath 方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次 lineto 方法。 （2）绘制矩形fillRect(x, y, width, height)方法用来绘制矩形，它的四个参数分别为矩形左上角顶点的 x 坐标、y 坐标，以及矩形的宽和高。fillStyle 属性用来设置矩形的填充色。 12345678910ctx.fillStyle = 'yellow';ctx.fillRect(50, 50, 200, 100);strokeRect 方法与 fillRect 类似，用来绘制空心矩形。ctx.strokeRect(10,10,200,100);clearRect 方法用来清除某个矩形区域的内容。ctx.clearRect(100,50,50,50); （3）绘制文本fillText(string, x, y) 用来绘制文本，它的三个参数分别为文本内容、起点的 x 坐标、y 坐标。使用之前，需用 font 设置字体、大小、样式（写法类似与 CSS 的 font 属性）。与此类似的还有 strokeText 方法，用来添加空心字。 12345678910// 设置字体ctx.font = "Bold 20px Arial";// 设置对齐方式ctx.textAlign = "left";// 设置填充颜色ctx.fillStyle = "#008600";// 设置字体内容，以及在画布上的位置ctx.fillText("Hello!", 10, 50);// 绘制空心字ctx.strokeText("Hello!", 10, 100); fillText 方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次 fillText 方法。 （4）绘制圆形和扇形arc 方法用来绘制扇形 1ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); arc 方法的 x 和 y 参数是圆心坐标，radius 是半径，startAngle 和 endAngle 则是扇形的起始角度和终止角度（以弧度表示），anticlockwise 表示做图时应该逆时针画（true）还是顺时针画（false）。 下面是如何绘制实心的圆形。 1234ctx.beginPath();ctx.arc(60, 60, 50, 0, Math.PI\*2, true);ctx.fillStyle = "#000000";ctx.fill(); 绘制空心圆形的例子。 12345ctx.beginPath();ctx.arc(60, 60, 50, 0, Math.PI\*2, true);ctx.lineWidth = 1.0;ctx.strokeStyle = "#000";ctx.stroke(); （5）设置渐变色createLinearGradient 方法用来设置渐变色。 12345var myGradient = ctx.createLinearGradient(0, 0, 0, 160);myGradient.addColorStop(0, "#BABABA");myGradient.addColorStop(1, "#636363"); createLinearGradient 方法的参数是(x1, y1, x2, y2)，其中 x1 和 y1 是起点坐标，x2 和 y2 是终点坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。 使用方法如下： 12ctx.fillStyle = myGradient;ctx.fillRect(10,10,200,100); （6）设置阴影一系列与阴影相关的方法，可以用来设置阴影。 1234567ctx.shadowOffsetX = 10; // 设置水平位移ctx.shadowOffsetY = 10; // 设置垂直位移ctx.shadowBlur = 5; // 设置模糊度ctx.shadowColor = "rgba(0,0,0,0.5)"; // 设置阴影颜色ctx.fillStyle = "#CC0000";ctx.fillRect(10,10,200,100); 图像处理方法drawImage 方法Canvas API 允许将图像文件插入画布，做法是读取图片后，使用 drawImage 方法在画布内进行重绘。 123var img = new Image();img.src = 'image.png';ctx.drawImage(img, 0, 0); // 设置对应的图像对象，以及它在画布上的位置 上面代码将一个 PNG 图像载入画布。drawImage()方法接受三个参数，第一个参数是图像文件的 DOM 元素（即节点），第二个和第三个参数是图像左上角在画布中的坐标，上例中的(0, 0)就表示将图像左上角放置在画布的左上角。 由于图像的载入需要时间，drawImage 方法只能在图像完全载入后才能调用，因此上面的代码需要改写。 12345678910111213var image = new Image();image.onload = function() &#123;var canvas = document.createElement('canvas');canvas.width = image.width;canvas.height = image.height;canvas.getContext('2d').drawImage(image, 0, 0);// 插入页面底部document.body.appendChild(image);return canvas;&#125;image.src = 'image.png'; getImageData 方法，putImageData 方法getImageData 方法可以用来读取 Canvas 的内容，返回一个对象，包含了每个像素的信息。 1var imageData = context.getImageData(0, 0, canvas.width, canvas.height); imageData 对象有一个 data 属性，它的值是一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha 通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是 0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用 putImageData 方法将数组内容重新绘制在 Canvas 上。 1context.putImageData(imageData, 0, 0); toDataURL 方法对图像数据做出修改以后，可以使用 toDataURL 方法，将 Canvas 数据重新转化成一般的图像文件形式。 12345function convertCanvasToImage(canvas) &#123;var image = new Image();image.src = canvas.toDataURL('image/png');return image;&#125; 上面的代码将 Canvas 数据，转化成 PNG data URI。 save 方法，restore 方法save 方法用于保存上下文环境，restore 方法用于恢复到上一次保存的上下文环境。 1234567891011121314ctx.save();ctx.shadowOffsetX = 10;ctx.shadowOffsetY = 10;ctx.shadowBlur = 5;ctx.shadowColor = 'rgba(0,0,0,0.5)';ctx.fillStyle = '#CC0000';ctx.fillRect(10,10,150,100);ctx.restore();ctx.fillStyle = '#000000';ctx.fillRect(180,10,150,100); 上面代码先用 save 方法，保存了当前设置，然后绘制了一个有阴影的矩形。接着，使用 restore 方法，恢复了保存前的设置，绘制了一个没有阴影的矩形。 动画利用 JavaScript，可以在 canvas 元素上很容易地产生动画效果。 123456789101112131415161718var posX = 20,posY = 100;setInterval(function() &#123;context.fillStyle = "black";context.fillRect(0,0,canvas.width, canvas.height); posX += 1; posY += 0.25; context.beginPath(); context.fillStyle = "white"; context.arc(posX, posY, 10, 0, Math.PI*2, true); context.closePath(); context.fill();&#125;, 30); 上面代码会产生一个小圆点，每隔 30 毫秒就向右下方移动的效果。setInterval 函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。 通过设置圆心坐标，可以产生各种运动轨迹。 先上升后下降。 12345678910var vx = 10,vy = -10,gravity = 1;setInterval(function() &#123;posX += vx;posY += vy;vy += gravity;// ...&#125;); 上面代码中，x 坐标始终增大，表示持续向右运动。y 坐标先变小，然后在重力作用下，不断增大，表示先上升后下降。 小球不断反弹后，逐步趋于静止。 123456789101112131415161718var vx = 10,vy = -10,gravity = 1;setInterval(function() &#123;posX += vx;posY += vy; if (posY &gt; canvas.height * 0.75) &#123; vy *= -0.6; vx *= 0.75; posY = canvas.height * 0.75; &#125; vy += gravity; // ...&#125;); 上面代码表示，一旦小球的 y 坐标处于屏幕下方 75%的位置，向 x 轴移动的速度变为原来的 75%，而向 y 轴反弹上一次反弹高度的 40%。 像素处理通过 getImageData 方法和 putImageData 方法，可以处理每个像素，进而操作图像内容。 假定 filter 是一个处理像素的函数，那么整个对 Canvas 的处理流程，可以用下面的代码表示。 123456789if (canvas.width &gt; 0 &amp;&amp; canvas.height &gt; 0) &#123; var imageData = context.getImageData(0, 0, canvas.width, canvas.height); filter(imageData); context.putImageData(imageData, 0, 0);&#125; 以下是几种常见的处理方法。 灰度效果灰度图（grayscale）就是取红、绿、蓝三个像素值的算术平均值，这实际上将图像转成了黑白形式。假定 d[i]是像素数组中一个象素的红色值，则 d[i+1]为绿色值，d[i+2]为蓝色值，d[i+3]就是 alpha 通道值。转成灰度的算法，就是将红、绿、蓝三个值相加后除以 3，再将结果写回数组。 1234567891011121314grayscale = function (pixels) &#123; var d = pixels.data; for (var i = 0; i &lt; d.length; i += 4) &#123; var r = d[i]; var g = d[i + 1]; var b = d[i + 2]; d[i] = d[i + 1] = d[i + 2] = (r+g+b)/3; &#125; return pixels;&#125;; 复古效果复古效果（sepia）则是将红、绿、蓝三个像素，分别取这三个值的某种加权平均值，使得图像有一种古旧的效果。 12345678910111213141516sepia = function (pixels) &#123; var d = pixels.data; for (var i = 0; i &lt; d.length; i += 4) &#123; var r = d[i]; var g = d[i + 1]; var b = d[i + 2]; d[i] = (r * 0.393)+(g * 0.769)+(b * 0.189); // red d[i + 1] = (r * 0.349)+(g * 0.686)+(b * 0.168); // green d[i + 2] = (r * 0.272)+(g * 0.534)+(b * 0.131); // blue &#125; return pixels;&#125;; 红色蒙版效果红色蒙版指的是，让图像呈现一种偏红的效果。算法是将红色通道设为红、绿、蓝三个值的平均值，而将绿色通道和蓝色通道都设为 0。 123456789101112131415red = function (pixels) &#123; var d = pixels.data; for (var i = 0; i &lt; d.length; i += 4) &#123; var r = d[i]; var g = d[i + 1]; var b = d[i + 2]; d[i] = (r+g+b)/3; // 红色通道取平均值 d[i + 1] = d[i + 2] = 0; // 绿色通道和蓝色通道都设为0 &#125; return pixels;&#125;; 亮度效果亮度效果（brightness）是指让图像变得更亮或更暗。算法将红色通道、绿色通道、蓝色通道，同时加上一个正值或负值。 12345678910111213brightness = function (pixels, delta) &#123; var d = pixels.data; for (var i = 0; i &lt; d.length; i += 4) &#123; d[i] += delta; // red d[i + 1] += delta; // green d[i + 2] += delta; // blue &#125; return pixels;&#125;; 反转效果反转效果（invert）是指图片呈现一种色彩颠倒的效果。算法为红、绿、蓝通道都取各自的相反值（255-原值）。 12345678910111213invert = function (pixels) &#123; var d = pixels.data; for (var i = 0; i &lt; d.length; i += 4) &#123; d[i] = 255 - d[i]; d[i+1] = 255 - d[i + 1]; d[i+2] = 255 - d[i + 2]; &#125; return pixels;&#125;; 一个简单的小栗子vue 动画小组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;template&gt; &lt;canvas ref="bubble" :width="width" :height="height" :style="style"&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt; export default &#123; props: &#123; y: &#123; type: Number, default: 0 &#125; &#125;, data() &#123; return &#123; width: 50, height: 80 &#125; &#125;, computed: &#123; distance() &#123; return Math.max(0, Math.min(this.y * this.ratio, this.maxDistance)) &#125;, style() &#123; return `width:$&#123;this.width / this.ratio&#125;px;height:$&#123;this.height / this.ratio&#125;px` &#125; &#125;, created() &#123; this.ratio = window.devicePixelRatio this.width *= this.ratio this.height *= this.ratio this.initRadius = 18 * this.ratio this.minHeadRadius = 12 * this.ratio this.minTailRadius = 5 * this.ratio this.initArrowRadius = 10 * this.ratio this.minArrowRadius = 6 * this.ratio this.arrowWidth = 3 * this.ratio this.maxDistance = 40 * this.ratio this.initCenterX = 25 * this.ratio this.initCenterY = 25 * this.ratio this.headCenter = &#123; x: this.initCenterX, y: this.initCenterY &#125; &#125;, mounted() &#123; this._draw() &#125;, methods: &#123; _draw() &#123; const bubble = this.$refs.bubble let ctx = bubble.getContext('2d') ctx.clearRect(0, 0, bubble.width, bubble.height) this._drawBubble(ctx) this._drawArrow(ctx) &#125;, _drawBubble(ctx) &#123; ctx.save() ctx.beginPath() const rate = this.distance / this.maxDistance const headRadius = this.initRadius - (this.initRadius - this.minHeadRadius) * rate this.headCenter.y = this.initCenterY - (this.initRadius - this.minHeadRadius) * rate // 画上半弧线 ctx.arc(this.headCenter.x, this.headCenter.y, headRadius, 0, Math.PI, true) // 画左侧贝塞尔 const tailRadius = this.initRadius - (this.initRadius - this.minTailRadius) * rate const tailCenter = &#123; x: this.headCenter.x, y: this.headCenter.y + this.distance &#125; const tailPointL = &#123; x: tailCenter.x - tailRadius, y: tailCenter.y &#125; const controlPointL = &#123; x: tailPointL.x, y: tailPointL.y - this.distance / 2 &#125; ctx.quadraticCurveTo(controlPointL.x, controlPointL.y, tailPointL.x, tailPointL.y) // 画下半弧线 ctx.arc(tailCenter.x, tailCenter.y, tailRadius, Math.PI, 0, true) // 画右侧贝塞尔 const headPointR = &#123; x: this.headCenter.x + headRadius, y: this.headCenter.y &#125; const controlPointR = &#123; x: tailCenter.x + tailRadius, y: headPointR.y + this.distance / 2 &#125; ctx.quadraticCurveTo(controlPointR.x, controlPointR.y, headPointR.x, headPointR.y) ctx.fillStyle = 'rgb(170,170,170)' ctx.fill() ctx.strokeStyle = 'rgb(153,153,153)' ctx.stroke() ctx.restore() &#125;, _drawArrow(ctx) &#123; ctx.save() ctx.beginPath() const rate = this.distance / this.maxDistance const arrowRadius = this.initArrowRadius - (this.initArrowRadius - this.minArrowRadius) * rate // 画内圆 ctx.arc(this.headCenter.x, this.headCenter.y, arrowRadius - (this.arrowWidth - rate), -Math.PI / 2, 0, true) // 画外圆 ctx.arc(this.headCenter.x, this.headCenter.y, arrowRadius, 0, Math.PI * 3 / 2, false) ctx.lineTo(this.headCenter.x, this.headCenter.y - arrowRadius - this.arrowWidth / 2 + rate) ctx.lineTo(this.headCenter.x + this.arrowWidth * 2 - rate * 2, this.headCenter.y - arrowRadius + this.arrowWidth / 2) ctx.lineTo(this.headCenter.x, this.headCenter.y - arrowRadius + this.arrowWidth * 3 / 2 - rate) ctx.fillStyle = 'rgb(255,255,255)' ctx.fill() ctx.strokeStyle = 'rgb(170,170,170)' ctx.stroke() ctx.restore() &#125; &#125;, watch: &#123; y() &#123; this._draw() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>画布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集小屋]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%94%B6%E9%9B%86%E5%B0%8F%E5%B1%8B%2F</url>
    <content type="text"><![CDATA[Vue + ElementUI 手撸后台管理网站基本框架(二)权限控制 https://blog.csdn.net/harsima/article/details/77949448 github vue 高星项目 https://www.vue-js.com/topic/5b9699fccd6b2d5e4fd9e53e VUE 导航网站，整合资源，持续更新！ https://www.vue-js.com/topic/5bbc5f28d87c33e71a870b9c axios 踩坑记录+拦截器使用+vue cli 代理跨域 proxy+webpack 打包部署到服务器 https://www.cnblogs.com/goloving/p/8901960.html#4016824 图片上传原理 https://juejin.im/post/590c1933128fe1005838a844 VueJS 模板系统–国际化 中/EN 切换 https://harsima.github.io/vue-backend/#/home Vue、Element-ui 项目中如何使用 Iconfont(阿里图标库) https://blog.csdn.net/qq_32113629/article/details/79740949 快速生成项目结构图 https://github.com/artiely/treeplus 前端工程师知识技能储备库 https://neveryu.github.io/web-bookmarks/ 轻松生成小程序分享海报 https://blog.csdn.net/rolan1993/article/details/82185373 3D 网站 https://threejs.org/ VueJs 监听 window.resize 方法 https://blog.csdn.net/liu4071325/article/details/83503719 Vue 中如何引入第三方 JS 库 https://blog.csdn.net/csdn_yudong/article/details/78795743 Base64 编码 及 在 HTML 中用 Base 编码直接显示图片或嵌入其他文件类型 https://blog.csdn.net/u013433821/article/details/45308455?locationNum=6 hexo 博客配置 https://www.simon96.online/2018/10/12/hexo-tutorial/ hexo next 主题搜集 https://yfzhou.coding.me/ 前端迷资料大全(Front-end fan) https://ru23.com/ 前端资料 https://www.jeffjade.com/ 淘宝前端团队(FED) http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/ 常用图床工具 获取云图片 https://blog.csdn.net/u012195214/article/details/79204607 用 canvas 的 toDataURL()将图片转为 dataURL(base64) https://blog.csdn.net/oulihong123/article/details/73927514 vue 移动端 flexible.js 结合 Muse-ui 使用的小坑 https://blog.csdn.net/zhanglong_web/article/details/78649717?utm_source=blogxgwz1 Shadowsocks 科学上网 https://thief.one/2017/02/22/Shadowsocks%E6%8A%98%E8%85%BE%E8%AE%B0/ iview 后台管理项目 https://project.vilson.xyz/#/personal/notice/list 正则表达式修饰符 i、g、m、s、U、x、a、D、e 等。 https://blog.csdn.net/qq_36340642/article/details/79352876 使用 readAsDataURL 方法预览/读取图片 https://blog.csdn.net/double215726/article/details/19154587 将 Canvas 画布 作为图片保存并下载 https://blog.csdn.net/freedomvenly/article/details/79339638 vue 资源文件夹 assets 和 static 的区别 https://blog.csdn.net/zgpeterliu/article/details/79719244 @media 如何使用？ https://blog.csdn.net/forest_fire/article/details/78970725 分享一个 WebGL 开发的网站-用 JavaScript + WebGL 开发 3D 模型 https://segmentfault.com/a/1190000016759140?utm_source=tag-newest 天下视频唯弹幕不破 https://juejin.im/post/5be54a286fb9a049ae07641b 博客中添加音乐播放功能 https://github.com/MoePlayer/hexo-tag-aplayer 《一步步带你做 vue 后台管理框架》——登录功能 https://www.jianshu.com/p/3ea678dfc9d3 手摸手，带你用 vue 撸后台 系列二(登录权限篇) https://juejin.im/post/591aa14f570c35006961acac axios 二次封装学习 https://juejin.im/post/5b714a44f265da27ea319fcb 浅谈 mock https://juejin.im/post/5bd82d796fb9a05d25682a66#heading-12 hexo orange 博客 https://orangexc.xyz/tags/index.html Web 前端导航 http://www.alloyteam.com/nav/ CDN 之西天取经 https://blog.csdn.net/lu_embedded/article/details/80519898 利用 jsdoc 为 vue 项目生成漂亮的文档 利用 jsdoc 为 vue 项目生成漂亮的文档 Vue 中使用 Axios 进行 POST 数据发生的参数问题和跨域问题 https://segmentfault.com/q/1010000012912650 axios 拦截器设置 baseURL https://segmentfault.com/q/1010000014810360 es6 学习笔记 https://github.com/hyy1115 vue 甘特图 https://github.com/mamboer/vue-easy-gantt 介绍项目的引导插件 https://github.com/kamranahmedse/driver.js 非父子传值组件 vue-happy-bus https://github.com/tangdaohai/vue-happy-bus 翻墙网站 https://fangeqiang.com/ ele 商家管理系统 https://github.com/bailicangdu/node-elm Vue 2.x 实战之后台管理系统开发 https://juejin.im/post/58f3799ca22b9d006cfa8d81#heading-13 最全 hexo -next 建站手册 https://www.jianshu.com/p/f9ceec12788a 年终回顾，为你汇总一份「前端技术清单」 https://github.com/alienzhou/frontend-tech-list]]></content>
      <categories>
        <category>ofen looking</category>
      </categories>
      <tags>
        <tag>college</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目结构tree图]]></title>
    <url>%2F2018%2F10%2F13%2F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[目录结构介绍|-- build // webpack配置文件 |-- config // 项目打包路径 |-- src // 源码目录 | |-- components // 组件 | |-- common // 公共组件 | |-- bus.js // Event Bus | |-- Header.vue // 公共头部 | |-- Home.vue // 公共路由入口 | |-- Sidebar.vue // 公共左边栏 | |-- Tags.vue // 页面切换标签组件 | |-- page // 主要路由页面 | |-- 403.vue | |-- 404.vue | |-- BaseCharts.vue // 基础图表 | |-- BaseForm.vue // 基础表单 | |-- BaseTable.vue // 基础表格 | |-- DashBoard.vue // 系统首页 | |-- DragList.vue // 拖拽列表组件 | |-- Icon.vue // 自定义图标组件 | |-- Login.vue // 登录 | |-- Markdown.vue // markdown组件 | |-- Premission.vue // 权限测试组件 | |-- Upload.vue // 图片上传 | |-- VueEditor.vue // 富文本编辑器 | |-- App.vue // 页面入口文件 | |-- main.js // 程序入口文件，加载各种公共组件 |-- .babelrc // ES6语法编译配置 |-- .editorconfig // 代码编写规格 |-- .gitignore // 忽略的文件 |-- index.html // 入口html文件 |-- package.json // 项目及工具的依赖配置文件 |-- README.md // 说明]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm报错]]></title>
    <url>%2F2018%2F10%2F13%2Fnpm%E6%8A%A5%E9%94%99%EF%BC%9Aerror%20code%20EINTEGRITY%2F</url>
    <content type="text"><![CDATA[今天 npm install 时候遇到类似的错误 解决办法: 一、升级 npmnpm i -g npm 二、删除 package-lock.json 三、删除缓存目录下的所有数据npm cache clean –force 四、验证缓存数据的有效性和完整性，清理垃圾数据npm cache verify 五、包问题包是在 windows 下发布的，在 linux 安装错误。排查方法：看日志，去除相关的包配置，再安装测试 一般到第四步即可完美解决]]></content>
      <categories>
        <category>工作常见问题</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于 js 原型链 AJAX 请求数据时解决缓存的办法 js 的继承 简单谈谈事件冒泡和事件捕获 闭包什么时候会用到有什么好处 三目运算符 图表的使用 AJAX 跨域如何解决 谈谈 Promise 的理解 递归 ES6 关于 JAVASCRIPT 自动化构建工具 GULP GRUNT WEBPACK 的了解 搭建项目步骤的演示 移动端兼容性问题 IE opacity 不起作用解决办法 Placeholder 不起作用解决办法 input 被键盘遮挡解决办法 audio 在微信里音乐无法自动播放 关于 CSS3 HTML5 CSS3 HTML5 新属性 LESS SASS 和 css 的区别 rem 和 px 的区别 微信登录 第三方支付 分享 地图 Geolocation WEbsockt 关于版本控制系统 GIT 的使用更新/提交代码pull／push 关于数据结构与算法## box-sizing: border-box 的作用当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。例如：&lt;div class=&quot;box&quot;&gt;举个例子&lt;/div&gt; 12345678.box &#123;width: 500px;height:100px;border: 1px solid #000;-webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 如果这时候你加上一个内边距属性，padding: 10px;这个 div 不会撑开，即你所见的边框位置没有任何变动，但是“举个例子”这句话会和 div 边框有 10px 的间距。一般在写页面的时候用这个属性就不会再考虑边框和内边距会改变整体所占宽度，即不用再根据盒子模型再去计算，省去很多麻烦。 在不使用第三个变量的情况下使俩个变量的值互换算术运算 12345int a,b;a=10;b=12;a=b-a; //a=2;b=12b=b-a; //a=2;b=10a=b+a; //a=10;b=10 它的原理是：把 a、b 看做数轴上的点，围绕两点间的距离来进行计算。具体过程：第一句“a=b-a”求出 ab 两点的距离，并且将其保存在 a 中；第二句“b=b-a”求出 a 到原点的距离（b 到原点的距离与 ab 两点距离之差），并且将其保存在 b 中；第三句“a=b+a”求出 b 到原点的距离（a 到原点距离与 ab 两点距离之和），并且将其保存在 a 中。完成交换。此算法与标准算法相比，多了三个计算的过程，但是没有借助临时变量。（以下称为算术算法） this 的指向：1、作为普通函数调用（this 指向全局对象 window 对象）2、作为对象的方法调用（this 指向该对象）3、构造器调用（this 指向用 new 返回的这个对象）4、call、apply、bind 的调用（this 指向第一个参数对象） new 操作符具体干了什么呢? 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 null 和 undefined 的区别？ null 是一个表示”无”的对象，转为数值时为 0；undefined 是一个表示”无”的原始值，转为数值时为 NaN。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 null 表示”没有对象”，即该处不应该有值。 call、apply、bind 的区别 三者都是用来改变函数的 this 对象的指向的。三者第一个参数都是 this 要指向的对象，也就是想指定的上下文。call 传入的参数数量不固定，第二部分参数要一个一个传，用，隔开。apply 接受两个参数，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。bind 是返回一个改变了上下文的函数副本，便于稍后调用；apply 、call 则是立即调用 。 ###本地存储 sessionStorage 和 localStorage 的区别 sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 cookie 和 session cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 COOKIE。 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。每次请求一个新的页面的时候 Cookie 都会被发送过去，与服务器进行交互。 XML 和 JSON 的区别？ 数据体积方面。JSON 相对于 XML 来讲，数据的体积小，传递的速度更快些。 数据交互方面。JSON 与 JavaScript 的交互更加方便，更容易解析处理，更好的数据交互。 数据描述方面。JSON 对数据的描述性比 XML 较差。 传输速度方面。JSON 的速度要远远快于 XML。 如何实现浏览器内多个标签页之间的通信?调用 localstorge、cookies 等本地存储方式 渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 性能优化网页内容 减少 http 请求次数减少 DNS 查询次数避免页面跳转缓存 Ajax延迟加载提前加载减少 DOM 元素数量避免 404服务器使用 CDN(内容分发网络)添加 Expires 或 Cache-Control 报文头Gzip 压缩传输文件CSS将样式表置顶用代替@importJavaScript把脚本置于页面底部使用外部 JavaScript 和 CSS精简 JavaScript 和 CSS去除重复脚本减少 DOM 访问图片优化图像优化 CSS Spirite不要在 HTML 中缩放图片favicon.ico 要小而且可缓存 如何解决跨域问题?jsonp、CORS、document.domain+iframe、window.name、window.postMessage jsonp 的原理就是利用了&lt;script&gt;标签可以链接到不同源的 js 脚本，来到达跨域目的。利用 页面上 script 标签可以跨域，并且其 src 指定的 js 脚本到达浏览器会执行的特性，我们可以进行跨域取得数据 请解释一下 JavaScript 的同源策略这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 哪些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） Javascript 垃圾回收方法 标记清除：这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 引用计数：引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1 如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。 事件、IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 阻止冒泡：e.stopPropagation() 说说严格模式的限制 变量必须声明后再使用函数的参数不能有同名属性，否则报错禁止 this 指向全局对象不能使用 with 语句增加了保留字arguments 不会自动反映函数参数的变化设立”严格模式”的目的： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。使用事件代理的好处是可以提高性能。 Event Loop、消息队列、事件轮询 缓存浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据， http 缓存http 缓存是基于 HTTP 协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件判断 expires，如果未过期，直接读取 http 缓存文件 ES6es6 是一个新的标准，它包含了许多新的语言特性和库，是 JS 最实质性的一次升级。比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入 module 模块的概念。 箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 async/await 是写异步代码的新方式，以前的方法有回调函数和 Promise。async/await 是基于 Promise 实现的，它不能用于普通的回调函数。async/await 与 Promise 一样，是非阻塞的。async/await 使得异步代码看起来像同步代码，这正是它的魔力所在。 说说你对 Promise 的理解Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点: 对象的状态不受外界影响，Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）一旦状态改变，就不会再变，任何时候都可以得到这个结果。 说说你对 AMD 和 Commonjs 的理解CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。 AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的。 Gulp、Webpack 比较Gulp Gulp 就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock 数据等功能的一个前端自动化构建工具。 Gulp 就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。 Gulp 是通过 task 对整个开发过程进行构建。 Webpack 当下最热门的前端资源模块化管理和打包工具 可以很好的管理模块以及各个模块之间的依赖 对 js、css、图片等资源文件都支持打包 有独立的配置文件 webpack.config.js 可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间 可以生成优化且合并后的静态资源 两大特色： 代码可以自动完成编译。 loader 可以处理各种类型的静态文件，并且支持串联操作 CSSdisplay:none 和 visibility:hidden 的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position:absolute 和 float 属性的异同A：共同点：对内联元素设置 float 和 absolute 属性，可以让元素脱离文档流，并且可以设置其宽高。 B：不同点：float 仍会占据位置，position 会覆盖文档流中的其他元素。 box-sizing 属性content-box：让元素维持 W3C 的标准盒模型。元素的宽度/高度由 border + padding + content 的宽度/高度决定，设置 width/height 属性指的是 content 部分的宽/高，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 border-box：让元素维持 IE 传统盒模型（IE6 以下版本和 IE6~7 的怪异模式）。设置 width/height 属性指的是 border + padding + content position 的值static 默认值。没有定位，元素出现在正常的流中relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。absolute 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。fixed （老 IE 不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。 CSS3 新特性CSS3 实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜增加了更多的 CSS 选择器 多背景 rgba在 CSS3 中唯一引入的伪元素是::selection.媒体查询，多栏布局 CSS spritesCSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是 6 个。对于未来而言，就不需要这样做了，因为有了 http2。 ###解释下浮动和它的工作原理？清除浮动的技巧 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 使用空标签清除浮动。这种方法是在所有浮动标签后面添加一个空标签 定义 css clear:both. 弊端就是增加了无意义标签。 使用 overflow。设置 overflow 为 hidden 或者 auto，给包含浮动元素的父标签添加 css 属性 overflow:auto; zoom:1; zoom:1 用于兼容 IE6。 使用 after 伪对象清除浮动。该方法只适用于非 IE 浏览器。该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 1234567box:after&#123;content:".";height:0;visibility:hidden;display:block;clear:both;&#125; 浮动元素引起的问题 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 HTML说说你对语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 告知浏览器的解析器用什么文档标准解析这个文档。 严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 &lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种 Doctype 文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML 与 XHTML——二者有什么区别 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的 XML 标记都必须合理嵌套 所有的属性必须用引号””括起来 把所有&lt;和&amp;特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使“–” 图片必须有说明文字 html5 有哪些新特性语义化更好的内容标签（header,nav,footer,aside,article,section）音频、视频 API(audio,video)画布(Canvas) API地理(Geolocation) API拖拽释放(Drag and drop) API本地离线存储表单控件，calendar、date、time、email、url、search 一个完整的 URL 包括以下几部分http://www.hzzly.net:8080/new... 协议部分 域名部分 端口部分 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止 文件名部分：从域名后的最后一个“/”开始到“？”为止 参数部分：从“？”开始到“#”为止之间的部分 锚部分：从“#”开始到最后 GET 和 POST 的区别GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 1024 字节，Get 是通过地址栏来传值。 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post 是通过提交表单来传值。 数组排序冒泡排序相邻两个对比，最后把最大的排到了最后，重复此过程。 12345678910111213function f1(arr) &#123;var len = arr.length;for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125;&#125;return arr;&#125; 选择排序寻找最小的数，保存索引，然后与第一层循环其下标对于的值进行交换 1234567891011121314151617function selectionSort(arr) &#123;var len = arr.length;var minIndex, temp;for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp;&#125;return arr;&#125; 快速排序选取一个记录作为中间轴，然后将比‘这个记录值’小的移到‘记录值’之前，大的移到之后，然后递归 1234567891011121314151617function quickSort(arr) &#123;if(arr.length == 0) &#123; return []; // 返回空数组&#125;var cIndex = Math.floor(arr.length / 2);var c = arr.splice(cIndex, 1);var l = [];var r = [];for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125;&#125;return quickSort(l).concat(c, quickSort(r)); 数组去重方法 filter()+indexOf() 12345678910function sort1(arr) &#123; var result = new Array(); arr.forEach((item, index, array) =&gt; &#123; if (result.indexOf(item) == -1) result.push(item); &#125;) return result; &#125; var arr=[1,1,1,2,2,2,3,3,3] console.log(sort1(arr)) forEach()+indexOf() 12345678910function sort(arr) &#123; var result = new Array(); arr.forEach((item, index, array) =&gt; &#123; if (result.indexOf(item) == -1) result.push(item); &#125;) return result; &#125;var arr=[1,1,1,2,2,2,3,3,3]console.log(sort(arr)) for循环(一次)+indexOf() 12345678910function sort(arr) &#123; var result = new Array(); for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) == -1) result.push(arr[i]); &#125; return result; &#125; var arr=[1,1,1,2,2,2,3,3,3] console.log(sort(arr)) set() 集合是一种无重复元素的列表 123let arr = [1,2,3,4,3,2,1] let result = [...new set (arr)] console.log(result)]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中简约强大数组操作组合]]></title>
    <url>%2F2018%2F09%2F07%2FES6%E4%B8%AD%E7%AE%80%E7%BA%A6%E5%BC%BA%E5%A4%A7%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[ES6 数组新增方法reducearray.reduce(callback[, initialValue]) 数组求和 12345const numbers = [10, 20, 30, 40]numbers.reduce((prev, cur, index, arr) =&gt; &#123; console.log('prev: ' + prev + '; ' + 'cur: ' + cur + ';') return prev + cur&#125;) 123456prev: 10cur: 20prev: 30cur: 30prev: 60cur: 40 这第二个参数就是设置 prev 的初始类型和初始值，比如为 0，就表示 prev 的初始值为 number 类型，值为 0，因此，reduce 的最终结果也会是 number 类型。 12345const numbers = [10, 20, 30, 40]numbers.reduce((prev, cur, index, arr) =&gt; &#123; console.log('prev: ' + prev + '; ' + 'cur: ' + cur + ';') return prev + cur&#125;, 0) 12345678prev: 0cur: 10prev: 10cur: 20prev: 30cur: 30prev: 60cur: 40 参考： https://www.zhangxinxu.com/wordpress/2013/04/es5%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/ https://segmentfault.com/a/1190000005921341 https://segmentfault.com/a/1190000013972464 https://segmentfault.com/a/1190000013121115]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干掉状态从session到token]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%B9%B2%E6%8E%89%E7%8A%B6%E6%80%81%E4%BB%8Esession%E5%88%B0token%2F</url>
    <content type="text"><![CDATA[美好的旧时光我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。 上班的时候偶尔有些 HTTP 的请求发到我这里， 我简单的看一下， 取出相对应的 html 文档，图片，发回去就可以了， 然后就可以继续喝茶聊天。 我的创造者们对我很好， 他们制定的一个简单 HTTP 协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了 HTTP 请求， 每个请求对我来说都是全新的！ 邮件服务器很羡慕我， 他说：老弟，你的生活太惬意了， 哪像我， 每次有人从客户端访问邮箱， 我都得专门给他建立一个会话， 来处理他发的消息， 你倒好， 完全不用管理会话。 这是由应用的特性决定的， 如果邮件服务器不管理会话， 那多个人之间的邮件消息就会完全混到一起了， 乱作一团了。 而 30 年前的 Web 基本上就是文档的浏览而已， 既然是浏览，我作为一个服务器， 为什么要记住谁在一段时间里都浏览了什么文档呢？ 2 Session但是好日子没持续多久， 很快大家就不满足于静态的 Html 文档了， 交互式的 Web 应用开始兴起， 尤其是论坛， 在线购物等网站。 我马上就遇到了和邮件服务器一样的问题， 那就是必须管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放了商品， 也就是说我必须把每个人区分开。 这对我来说是个不小的挑战， 由于 HTTP 协议的无状态特性， 我必须加点小手段，才能完成会话管理。 我想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字符串，每个人收到的都不一样， 每次大家向我发起 HTTP 请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了。 3 沉重的负担大家都很高兴， 可是我就不爽了。 每个人只需要保存自己的 session id，而我需要保存所有人的 session id ！ 如果访问我的人多了， 就得由成千上万，甚至几十万个。 这对我来说是一个巨大的开销 ， 严重的限制了我的扩展能力， 比如说我用两个机器组成了一个集群， 小 F 通过机器 A 登录了系统， 那 session id 会保存在机器 A 上， 假设小 F 的下一次请求被转发到机器 B 怎么办？ 机器 B 可没有小 F 的 session id 啊。 有时候我会采用一点小伎俩： session sticky ， 就是让小 F 的请求一直粘连在机器 A 上， 但是这也不管用， 要是机器 A 挂掉了， 还得转到机器 B 去。 那我只好做 session 的复制了， 把 session id 在两个机器之间搬来搬去， 快累死了。 后来有个叫 Memcached 的给我支了招： 把 session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责 session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。 我也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的 session 对我来说是一个沉重的负担。 4 时间换空间这几天的晚上我一直在思考， 我为什么要保存这可恶的 session 呢， 只让每个客户端去保存该多好？ 可是如果我不保存这些 session id , 我怎么验证客户端发给我的 session id 的确是我生成的呢？ 如果我不去验证，我都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造 session id , 为所欲为了。 嗯，对了，关键点就是验证 ！ 比如说， 小 F 已经登录了系统， 我给他发一个 令牌(token)， 里边包含了小 F 的 user id， 下一次小 F 再次通过 Http 请求访问我的时候， 把这个 token 通过 Http header 带过来不就可以了。 不过这和 session id 没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。 那就对数据做一个签名吧， 比如说我用 HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为 token ， 由于密钥别人不知道， 就无法伪造 token 了。 这个 token 我不保存， 当小 F 把这个 token 给我发过来的时候，我再用同样的 HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和 token 中的签名做个比较， 如果相同， 我就知道小 F 已经登录过了，并且可以直接取到小 F 的 user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用 Base64 做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。 当然， 如果一个人的 token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的 session id 被别人偷走是一样的。 这样一来， 我就不保存 session id 了， 我只是生成 token , 然后验证 token ， 我用我的 CPU 计算时间获取了我的 session 存储空间 ！ 解除了 session id 这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！ （完）]]></content>
      <categories>
        <category>状态保持</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui更换主题和按需引入组件]]></title>
    <url>%2F2018%2F09%2F04%2Felement-ui%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[element-ui 使用初体验前言手上有些项目用的element-ui，刚好有空琢磨一下怎么减小打包文件大小和打包速度方面，为了演示实验，用 vue-cli 生成初始项目，在这仅对 element-ui 主题和组件方面来优化。 1vue init webpack vuecli 完整引入完整地将 ui 和样式引入。 12import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css' 在页面简单使用三个组件，看看效果。 1234567891011121314&lt;div class="block"&gt; &lt;span class="demonstration"&gt;区分颜色&lt;/span&gt; &lt;el-rate v-model="value1" :colors="['#99A9BF', '#F7BA2A', '#FF9900']"&gt; &lt;/el-rate&gt;&lt;/div&gt;&lt;el-button type="primary" icon="el-icon-edit"&gt;&lt;/el-button&gt;&lt;el-row&gt; &lt;el-button icon="el-icon-search" circle&gt;&lt;/el-button&gt; &lt;el-button type="primary" icon="el-icon-edit" circle&gt;&lt;/el-button&gt; &lt;el-button type="success" icon="el-icon-check" circle&gt;&lt;/el-button&gt; &lt;el-button type="info" icon="el-icon-message" circle&gt;&lt;/el-button&gt; &lt;el-button type="warning" icon="el-icon-star-off" circle&gt;&lt;/el-button&gt; &lt;el-button type="danger" icon="el-icon-delete" circle&gt;&lt;/el-button&gt;&lt;/el-row&gt; 再看一下打包后的资源大小情况npm run build --report。 1234567891011121314Hash: fa47514a97341329a7c0Version: webpack 3.11.0Time: 20363ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/vendor.5efcf828140d5dbedda9.js 714 kB 0 [emitted] [big] vendor static/js/app.a4a31db472f653b911e7.js 12 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.f24bb0ae3686720fe2e00c5a2024b8f1.css 185 kB 1 [emitted] appstatic/css/app.f24bb0ae3686720fe2e00c5a2024b8f1.css.map 267 kB [emitted] static/js/vendor.5efcf828140d5dbedda9.js.map 2.73 MB 0 [emitted] vendor static/js/app.a4a31db472f653b911e7.js.map 22.8 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] 发现打包后提取公共模块static/js/vendor.js有 714kb 再看一下各个模块占用情况： 发现elment-ui.common.js占用最大。所有模块资源总共有 708kb。怎么才能减小打包后的大小呢？很容易就会想到 ui 的引入和样式的引入中，实际我们只使用了三个组件，却整体都被打包了，在这里引入这三个组件即可。 按需引入组件样式新建一个element-variables.scss文件（为什么是 SCSS 文件，后面自定义主题会用到）。 12345678/*icon字体路径变量*/$--font-path: "~element-ui/lib/theme-chalk/fonts";/*按需引入用到的组件的scss文件和基础scss文件*/@import "~element-ui/packages/theme-chalk/src/base.scss";@import "~element-ui/packages/theme-chalk/src/rate.scss";@import "~element-ui/packages/theme-chalk/src/button.scss";@import "~element-ui/packages/theme-chalk/src/row.scss"; 按需引入组件新建一个elementConfig.js文件，将项目用到的 element 组件引入。 123456789import &#123; Rate, Row, Button &#125; from 'element-ui'export default &#123; install(V) &#123; V.use(Rate) V.use(Button) V.use(Row) &#125;&#125; 第一次优化后打包分析将以上element-variables.scss和elementConfig.js引入到main.js中。 1234import ElementUI from '@/assets/js/elementConfig'import '@/assets/css/element-variables.scss'Vue.use(ElementUI) 貌似上面一切都很顺理成章，打包后大小会减小。 1234567891011121314Hash: 3ba9b74482f121efd3aaVersion: webpack 3.11.0Time: 18854ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/vendor.11c71f168a2d61b547a0.js 714 kB 0 [emitted] [big] vendor static/js/app.dbb5b49dad2d42b3598c.js 11.2 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.bf52525d6279e7fb87b4db770d119a8d.css 25.7 kB 1 [emitted] appstatic/css/app.bf52525d6279e7fb87b4db770d119a8d.css.map 63 kB [emitted] static/js/vendor.11c71f168a2d61b547a0.js.map 2.73 MB 0 [emitted] vendor static/js/app.dbb5b49dad2d42b3598c.js.map 21 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] 结果可知，static/js/vendor.js还是 714kb！ 再看各个模块占用情况： WHAT?竟然模块都没什么变化，岂不是竹篮打水，事与愿违。 再次打包优化尝试后来查到有人同样遇到这个问题，提出一个issues#6362，原来只引入需要的element-ui组件，webpack还是把整体的 ui 库和样式都打包了，需要一个webpack的babel插件babel-plugin-component，这样才能真正按需引入打包。这块其实被写到官方文档更换 自定义主题 的配置了。 于是npm i babel-pugin-componet -D安装后，在增加.babelrc文件插件配置 123456789101112131415&#123; "presets": [ ["env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125; &#125;], "stage-2" ], "plugins": ["transform-vue-jsx", "transform-runtime", ["component", &#123; "libraryName": "element-ui", "styleLibraryName": "theme-chalk" &#125;]]&#125; 页面运行正常，再次打包。 1234567891011121314Hash: 9cc71dead6d7646c9ed4Version: webpack 3.11.0Time: 9963ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/app.77c0883f4f0fc0bf5cbc.js 11.4 kB 0 [emitted] app static/js/vendor.942130fd13274b901889.js 126 kB 1 [emitted] vendor static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.b140020e5dbee406ae70780b43ba7ddc.css 27.8 kB 0 [emitted] appstatic/css/app.b140020e5dbee406ae70780b43ba7ddc.css.map 91.4 kB [emitted] static/js/app.77c0883f4f0fc0bf5cbc.js.map 21.1 kB 0 [emitted] app static/js/vendor.942130fd13274b901889.js.map 613 kB 1 [emitted] vendor static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] static/js/vendor.js确实变小了，126kB。再来看各个模块分析图。 模块总共 135.03KB，少了 5 倍！ 更换主题element-ui的theme-chalk使用SCSS编写，如果在自己的项目中也是用SCSS，那么可以直接在项目中改变样式变量，因此可以在前面新建的element-variables.scss文件用新的主题颜色变量覆盖即可。 12345/*主题颜色变量*/$--color-primary: #f0f;/*icon字体路径变量*/$--font-path: "~element-ui/lib/theme-chalk/fonts"; 可能你已经注意到了，这里没有分别引入用到的组件样式了，是因为babel-plugin-component帮我们按需引入了对应的样式。 现在我们的主题就变成了 如果你没有用到SCSS，可以用element-theme主题编译插件，生成自定义主题文件引入。 完~ps：个人见解有限，欢迎指正。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端必备vscode插件]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87vscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言这篇文章只要让你做一些基础的配置，把 vscode 变得更加顺手；插件的需求不是一成不变，有些插件我已经移除了。。在最新的 VSCODE 1.9.1 中，部分以前用插件实现的功能已经集成了，那就没有必要存在了。这里就不做推荐了复制代码 必备插件 功能性 Auto Close Tag : 匹配标签，关闭对应的标签。很实用【HTML/XML】 Auto Rename Tag : sublime 和 webstorm 也有这个内置功能，改变标签的时候同时改动开闭合标签；【HTML/XML】 beautify : 良好的拓展性，可以格式化 JSON|JS|HTML|CSS|SCSS,比内置格式化好用 Code Runner : 代码编译运行看结果，支持众多语言 colorize : 会给颜色代码增加一个当前匹配代码颜色的背景，非常好 Document This : JSDOC 注解调用，值得易用 Git History : 不得不赞的插件，谁用谁知道，功能很赞 HTML CSS Support : 这个也是必备插件之一 Path Autocomplete : 路径智能补全 Path Intellisense ： 路径智能提示 SCSS IntelliSense Preview : SCSS 智能提醒，配置强大 Syncing: 这个同步插件要比官方市场那个最高下载量的要好，支持删除同步！！！ Version Lens : 可以及时看到 package.json 内部版本的变动，很实用 Output Colorizer : 可以终端日志输出着色，实用 代码片段插件12JavaScript (ES6) code snippets : ES6的代码片段，实用JavaScript Snippet Pack : ES5及以下的代码片段，实用 语法校验1stylelint : 比内置的要全，更智能 主题 Panda:用了相当久的一套颜色高亮，个人感觉很耐看 Enki Theme (Material Design Inspired) : 当前用的代码高亮，个人感觉很赞 Material Icon Theme : 一套扁平化的文件图标，内置的 seti 也很优秀，还有 simple icon 和 vscode-icons 作者：爱吃 kiwi链接：https://leekiwi.github.io/来源：github著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>实用</category>
      </categories>
      <tags>
        <tag>插件 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs学习笔记]]></title>
    <url>%2F2018%2F08%2F28%2Fnode.js%20study%20note%2F</url>
    <content type="text"><![CDATA[Nodejs 学习笔记node 内部对模块输出 module.exports 的实现 变量 module 是 Node 在加载 js 文件前准备的一个变量，并将其传入加载函数 12345678910111213141516171819202122// 准备module对象var module = &#123; id: 'hello', exports: &#123;&#125;&#125;;var load = function(module) &#123; // 读取的hello.js代码 function greet(name) &#123; console.log('Hello, ' + name + '!'); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;;var exported = load(module);// 保存modulesave(module, exported); 默认情况下，Node 准备的 exports 变量和 module.exports 变量实际上是同一个变量，所以一下两种写法都支持 123456789101112// method 1module.exports = &#123; foo: foo, bar: bar&#125;;ormodule.exports.foo = foo;module.exports.bar = bar;// method 2exports.foo = foo;exports.bar = bar; process 下一轮事件循环 回调 123process.nextTick(function() &#123; console.log('nextTick callback');&#125;); 程序即将退出 回调 12345process.on('exit', function(code) &#123; console.log('about to exit with code' + code);&#125;);console.log('nextTick set'); readFile/readFileSync writeFile/writeFileSync stat 异步读取一个文本文件 123456789fs.readFile('./hello.js', 'utf-8', function(err, data) &#123; console.log('read file start...'); if(err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 异步读取一个二进制文件 12345678910111213fs.readFile('1.jpg', function(err, data) &#123; if(err) &#123; console.log(err); &#125; else &#123; // 返回一个buffer对象 console.log(data); // Buffer对象转化成字符串 console.log(data.toString('utf-8')); // 文件大小 console.log(data.length + ' bytes'); &#125;&#125;); 同步读取一个文件直接返回，读取错误用 try…catch 捕获 123456789try &#123; var data = fs.readFileSync('./1.jpg'); console.log(data);&#125;catch(err) &#123; console.log(err);&#125;console.log('readFileSync ended'); 异步写入一个文件，默认是以 UTF-8 编码写入文本文件 12345678910var data = 'Hello,Node.js';// var data = fs.readFileSync('./1.jpg');fs.writeFile('output.txt', data, function(err) &#123; if(err) &#123; console.log(err); &#125; else &#123; console.log('write file finished'); &#125;&#125;); 同步写入文本到一个文件 123var data = 'Hello,Node.js,I am sync data';fs.writeFileSync('output.txt', data);console.log('writeFileSync ended'); 获取文件信息 1234567891011121314151617181920fs.stat('./1.jpg', function(err, stat) &#123; if(err) &#123; console.log(err); &#125; else &#123; // 是否是文件 console.log('isFile:' + stat.isFile()); // 是否是目录 console.log('isDirectory:' + stat.isDirectory()); if(stat.isFile()) &#123; // 文件大小 console.log('size:' + stat.size); // 创建时间，Date对象 console.log('birth time:' + stat.birthtime); // 修改时间，Date对象 console.log('modified time:' + stat.mtime); &#125; &#125;&#125;); PS:绝大部分需要在服务器运行期反复执行业务逻辑，必须使用异步代码服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码 createReadStream createWriteStream pipe 在 node.js 中，流也是一个对象，我们只需要响应流的事件就可以了。data 事件表示流的数据已经可以读取了，end 事件表示这个流已经到末尾了，没有数据可以读取了，error 事件表示出错。 1234567891011121314var rs = fs.createReadStream('./data.txt', 'utf-8');// data事件可能有多次，每次传递的chunk是流的一部分数据rs.on('data', function(chunk) &#123; console.log('data event:', chunk);&#125;);rs.on('end', function (chunk) &#123; console.log('end event:');&#125;);rs.on('error', function (chunk) &#123; console.log('error event:');&#125;); 以流的形式写入文件，只需要不断调用 write()方法，最后以 end()结束 12345var ws = fs.createWriteStream('./data.txt');ws.write('user stream write data\n');ws.write('loading...\n');ws.write('END');ws.end(); pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里 1234var rs = fs.createReadStream('./data.txt');var ors = fs.createReadStream('./output.txt');var ws = fs.createWriteStream('./output.txt');rs.pipe(ws); 创建一个服务器 123456789101112131415var server = http.createServer(function(request, response) &#123; // http请求头的method和url console.log('header meathod:', request.method); console.log('header url:', request.url); // 将http响应200写入response，同时设置content-type response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 将http响应的html内容写入response response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);server.listen(8080);console.log('Server is running at http://localhost:8080'); 实现一个文件服务器，拼接访问路径读取本地文件，从命令参数获取 root 目录，默认是当前目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var root = path.resolve('.');console.log('Static root dir:' + root);// 创建服务器 var server = http.createServer(function (request, response) &#123; // node提供url模块解析url字符串 获取url的path var pathname = url.parse(request.url).pathname; if (pathname === '/favicon.ico') &#123; return; &#125; console.log('url:', url.parse(request.url)); // 获取对应本地文件路径 var filepath = path.join(root, pathname); // 读取文件状态 fs.stat(filepath, function (err, stats) &#123; // 文件出错 if (err) &#123; console.log('file error!'); response.end('&lt;h1&gt;file error!&lt;/h1&gt;'); return; &#125; // 是文件 if (stats.isFile()) &#123; console.log('200 ' + request.url); response.writeHead(200); // 将文件流导入response fs.createReadStream(filepath).pipe(response); &#125; // 文件不存在 else &#123; console.log('404 ' + request.url); response.writeHead(404); // 将文件流导入response response.end('&lt;h1&gt;404 not found!&lt;/h1&gt;'); &#125; &#125;);&#125;);server.listen(8080);console.info('Server is runing at http://localhost:8080/'); express 是第一代流行的 web 框架，它对 Node.js 的 HTTP 进行封装，语法基于 ES5，要实现异步代码，只有一个方法：回调。 koa2 完全基于 ES7 开发，使用 Promise 配合 async 实现异步 1234567891011121314151617181920212223242526272829// 创建一个Koa对象const app = new Koa();// 对于任何请求，app将调用该异步函数处理请求// ctx是koa封装request和response变量// next是koa传入的将要处理下一个异步函数// 每个async函数称为middleware// app.use()顺序决定了middleware的顺序app.use(async(ctx, next) =&gt; &#123; fs.readFile('./data.txt', 'utf-8', function(err, data) &#123; console.log(data); &#125;); // 调用下一个middleware，如果没有调用，则下一个middleware不会执行 await next();&#125;);app.use(async(ctx, next) =&gt; &#123; ctx.response.type = 'text/html'; ctx.response.body = '&lt;h1&gt;Hello, koa!&lt;/h1&gt;'; console.log('response end'); // 调用下一个middleware await next();&#125;);app.listen(3000);console.log('app started at http://localhost:3000/');]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDN原理介绍]]></title>
    <url>%2F2018%2F08%2F27%2FCDN%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CDN 原理剖析 内容分发网络（Content delivery network 或 Content distribution network，缩写：CDN）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 为什么需要 CDN根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而 HTTP 传输时延对 web 的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由 TCP/IP 协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。 要提高访问速度，最简单的做法当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像 Google 那样设置多个数据中心。但是多设几个服务器的问题也不少，一是多地部署时的困难，二是一致性没法保障，三则是管理困难、成本很高。实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。当然，这种方案真正做好了，甚至是比后续所说的使用 CDN 要好的。 CDN 是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用 CDN 实质上就是让 CDN 作为网站的门面，用户访问到的是 CDN 服务器，而不是直接访问到网站。由于 CDN 内部对 TCP 的优化、对静态资源的缓存、预取，加上用户访问 CDN 时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。 CDN 的原理 CDN 做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源 CDN 有个源站的概念，源站就是提供内容的站点(网站的真实服务器), 从源站取内容的过程叫做回源。 每次访问的具体流程如图（以最普通的 CDN 为例） 具体举个例子： 用户在首次访问 https://assets-cdn.github.com/pinned-octocat.svg , 假设不委托 local DNS 服务器递归查询，会经历以下几个过程 浏览器检查本地有没有这个东东的有效缓存，有则使用缓存，没有有效缓存则进行对assets-cdn.github.com的 DNS 查询，获得一个 CNAME 记录, igithub.map.fastly.net,值得注意的是，多个加速域名可以解析到同一个 CNAME，CDN 回源和缓存的时候考虑到了 hostname，+1； 进行对github.map.fastly.net的 DNS 查询，获得一个 A/AAAA 记录，给出地址103.245.222.133（视网站不同返回的不一样，可以有多个）, 这一步对 CDN 来说时十分重要的，它给出了离用户最近的边缘节点； 浏览器选一个返回的地址，然后进行真正的 http 请求，开始向103.245.222.133握手，握手完了把 http 请求头也发给了该边缘服务器; 边缘服务器检查自己的 cache 里面有没有https://assets-cdn.github.com/pinned-octocat.svg这个资源，有则返回给用户，如果没有，向 CDN 中心服务器发起请求; CDN 中心服务器检查自己的 cache 里面有没有这个资源，有则返回给边缘服务器，没有则回源; 中心服务器发现客户配置了github.map.fastly.net的回源地址(这个只有 cdn 会知道，假设是xxx.xxx.xxx.xxx)，就把 http 请求发到源站地址上，源站返回后返回给请求方; 可以看出 CDN 加速的原理很大部分是跟 DNS 挂钩在一起的，CDN 供应商几乎一定需要一个智能 DNS 服务器。CDN 可以拿到所有的明文数据，所以对数据安全性、保密性要求比较高的企业会选择自建 CDN 或者设置 NS 记录，指向自建的智能 DNS 服务器。 上述步骤每一步都可以缓存，注意是每一步！ 所以 CDN 要清除缓存很难，因为有很多服务器上的缓存要清除。无论是用户对边缘服务器的请求，还是 CDN 服务器的回源都可以使用 https。 注意，实际环境中图中每个服务器都可以是集群，甚至 CDN 分区域中心和总中心。]]></content>
      <categories>
        <category>用户体验</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对MVC、MVP和MVVM的简单认识]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%AF%B9MVC%E3%80%81MVP%E5%92%8CMVVM%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[MVVM 的前世与今生1. 先聊一下 MVCMVC：Model（模型） View（视图） Controller（控制器），主要是基于分层的目的，让彼此的职责分开。 View 通过 Controller 和 Model 联系，Controller 是 View 和 Model 的协调者，view 和 Model 不直接联系，基本联系都是单向的。 2. 顺带提下 MVPMVP：是从 MVC 模式演变而来的，都是通过 Controller/Presenter 负责逻辑的处理+Model 提供数据+View 负责显示。 在 MVP 中，Presenter 完全把 View 和 Model 进行分离，主要的程序逻辑在 Presenter 里实现。并且，Presenter 和 View 是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更 View 的时候可以保持 Presenter 不变。 3. 再聊聊 MVVNMVVM：Model + View + ViewModel，把 MVC 中的 Controller 和 MVP 中的 Presenter 改成 ViewModel view 的变化会自动更新到 ViewModel，ViewModel 的变化也会自动同步到 View 上显示。这种自动同步是因为 ViewModel 中的属性实现了 Observer，当属性变更时都能触发对应操作。 View 是 HTML 文本的 js 模板； ViewModel 是业务逻辑层（一切 js 可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在 viewmodel 里面负责监控俩边的数据）； Model 数据层，对数据的处理（与后台数据交互的增删改查） 提一下我熟悉的 MVVM 框架：vue.js，Vue.js 是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 4. 一句话总结下不同之处MVC 中联系是单向的，MVP 中 P 和 V 通过接口交互，MVVP 的联系是双向的]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 实现设备上设置统一]]></title>
    <url>%2F2018%2F08%2F24%2Fvscode%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[一键同步 vscode 上的插件准备工作：电脑上需安装 VSCode，拥有一个 github 账户。实现同步的功能主要依赖于 VSCode 插件 “Settings Sync” Setting Sync 可同步包含的所有扩展和完整的用户文件夹 设置文件 快捷键设置文件 Launch File Snippets Folder VSCode 扩展设置 工作空间 Setting Sync 快捷键 上传： Shift + Alt + U (Sync: Update / Upload Settings) 下载： Shift + Alt + D (Sync: Download Settings) 如果快捷键有冲突，可Ctrl + K + S快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择 Step1. 安装 同步插件”Settings Sync” Step2. 进入 github -&gt; Settings 在左侧 Developer settings -&gt; Personal access tokens Step3. 点击按钮 Generate new token 新增一个 token图 1:图 2:图 3:记住你自己生成的 token 值，在 VSCode 配置上回用得到，最好找个笔记保存下来。 Step4. 回到 VSCode 配置将 token 配置到本地(Sync: Update / Uplaod Settings) Shift + Alt + U 在弹窗里输入你的 token， 回车后会生成 syncSummary.txt 文件 syncSummary.txt 文件会存储 VSCode 的设置及所安装的插件列表有点类似 package.json 这样形式的文件可以将自己的 token 分享到自己的团队里面去，这样团队可以共用一套设置。 Step5. 设置上同步下载设置(Sync: Download Settings) Shift + Alt + D 在弹窗里输入你的 gist 值，稍后片刻便可同步成功 Step6. 如果要重置同步设置，变更其它 tokenCtrl+P / F1 弹出输入&gt;sync,即可重新配置你的其它 token 来同步]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>setting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则规则汇总对字符串的处理，一般分为字符串操作和正则操作。 字符串操作 str.search(regStr) 返回 regStr 在 str 中第一个出现的位置 str.replace(regStr,newStr) 返回替换在 str 中 regStr 后字符串 str.substring(n1,n2) 返回 str 从 n1 位置到 n2 位置前一个字符串 str.chartAt(n) 返回 n 位置字符 str.split(regStr) 返回以 regStr 隔开的数组 str.match(reg) 返回在 str 中符合正则 reg 的字符串数组 正则操作var reg=new RegExp(regStr,’i’); //创建正则对象 var reg=/regStr/i; //隐式创建正则对象 reg.test(str) str 是否包含 reg 返回 true/false reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引 基础用法 /a|b/ a 或 b /[abc]/ a 或 b 或 c /[a-zA-Z0-9]/ 所有数字和字母 /[^a-za-z0-9]/ 除了数字和字母 /.+/ 任意字符 /\d/ 等价于/[0-9]/ 数字 /\w/ 等价于/[a-z0-9_]/ 数字、字母和下划线 /\s/ 等价于/“ “/ 空格 /\D/ 等价于/[^0-9]/ 非数字 /\W/ 等价于/[^a-z0-9_]/ 除了数字、字母和划线 /\S/ 等价于/[^” “]/ 除了空格 /\d{n,m}/ 数字最少出现 n 次，最多出现 m 次 /\d{1,}/ 等价于/\d+/ 数字最少出现 1 次 /\d{0,}/ 等价于/\d*/ 数字最少出现 0 次 /\d{0,1}/ 等价于/\d?/ 数字最多出现 1 次 /^\d$/ 以数字开头且以数字结尾 /[\u4e00-\u9fa5]/ 汉字匹配范围 \b 单词边界 \B 非单词边界 ?=n 匹配任何其后紧接指定字符串 n 的字符串 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 疑难点在个人接触正则过程中遇到的一些不易理解的地方 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 表达式 描述 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\ ) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\ ies) 就是一个比 ‘industry\ industries’ 更简略的表达式。 (?=pattern 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95\ 98\ NT\ 2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\ 98\ NT\ 2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 一直对正则中的 match 和 exec 不易分清，下面来做一下比较。 1. matchmatch 方法属于 String 正则表达方法 语法: 1str.match(regexp) str：要进行匹配的字符串 regexp：一个正则表达式(或者由 RegExp()构造成的正则表达式) match 的用法主要区分就是正则表达式是否有全局标示 g 如果有 g 全局标志，那么返回的数组保存的是，所有匹配的内容。 如果没有 g 全局标志，那么返回的数组 arr.arr[0]保存的是完整的匹配.arr[1]保存的是第一个括号里捕获的字串，依此类推 arr[n]保存的是第 n 个括号捕获的内容。 2. exec与 match 方法不同 exec 属于正则表达式的方法 语法： 1var result1 = regexp.exec(str); regexp：正则表达式 str：要匹配的字串 exec 与 match 的关联就是 exec（g 有没有都无影响）就等价于不含有 g 全局标志的 match，即返回数组 arr[0]为匹配的完整串，其余的为括号里捕获的字符串。 但如果有 g 对 exec 本身的影响是，当一个具有 g 的正则表达式调用 exec()时，他将该对象的 lastIndex 设置到紧接这匹配子串的字符位置。当第二次调用 exec 时将从lastIndex 所指示的字符位置开始检索，利用这个特点可以反复调用 exec 遍历所有匹配，等价于 match 具有 g 标志。 1234var arrmatch = str.match(reg);for(var i =0; i &lt; arrmatch.length; i++)&#123; document.write(arrmatch[i] +"----&gt;");&#125; 可见上面的 exec 和 match 是等价的. reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引如： 1234567891011121314var str = "abc123bef345olj89,ed";var reg = /\d+/g;console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex); 总结 主要区分 match 具有 g 和没有 g 的区别，没有 g 的时候与 exec 是等价的。 而 exec 返回的串类型不受 g 影响，但具有 g 时候会驱动 lastIndex 可以模拟遍历所有匹配，可以与 match 具有 g 的时候等价。 顺便加强理解 ip 正则表达式格式由”.”分割成四段，每一段范围是 0-255，拿出其中一段进行分析 范围 表达式 0-9 \d 10-99 [1-9]\d 100-199 1\d{2} 200-249 2[0-4]\d 250-255 25[0-5] 所以，其中一段构成的正则表达式是 1\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5] ，整个 ip 正则为 1/^(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/ 同理端口号范围是 0-65535 范围 表达式 0-9 \d 10-99 [1-9]\d 100-999 [1-9]\d{2} 1000-9999 [1-9]\d{3} 10000-59999 [1-5]\d{4} 60000-64999 6[0-4]\d{3} 65000-65499 65[0-4]\d{2} 65500-65529 655[0-2]\d 65530-65535 65553[0-5] 所以，整个端口号正则为 1/\d|[1-9]\d&#123;1,3&#125;|[1-5]d&#123;4&#125;|6[0-4]\d&#123;3&#125;|65[0-4]\d&#123;2&#125;|655[0-2]\d|65553[0-5]/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript 正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解同步、异步和事件循环]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[JavaScript 运行机制 所有同步任务都在主线程上执行，形成一个执行栈； 主线程发起异步请求，相应的工作线程就会去执行异步任务，主线程可以继续执行后面的代码； 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件，也就是一个消息； 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行； 主线程把当前的事件执行完成之后，再去读取任务队列，如此反复重复执行，这样就行程了事件循环。 1、单线程JS 引擎在解释和执行 JavaScript 代码线程只有一个，叫做主线程。但实际还存在其他线程，如：处理 Ajax 请求线程，处理 DOM 事件线程，定时器线程，和文件读写线程等，叫做工作线程。 2、同步和异步同步：如果函数返回的时候，调用者就能够得到预期结果。 1Math.sqrt(2); 异步：函数返回的时候，调用者还不能够得到预期结果，而是需要通过一定手段得到。 123fs.readFile("foo.txt", "utf8", function(err, data)&#123; console.log(data)&#125;) 上面代码中，我们希望 fs.readFile 函数读取文件，并打印出来，但是在 fs.readFile 函数返回时，我们期望的结果并不会发生，而是要等文件全部读取完成之后。 异步 AJAX： 主线程：“你好，AJAX 线程。请你帮我发个 HTTP 请求吧，我把请求地址和参数都给你了。” AJAX 线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。” 主线程：：“谢谢，你拿到响应后告诉我一声啊。” (接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。) 同步 AJAX： 主线程：“你好，AJAX 线程。请你帮我发个 HTTP 请求吧，我把请求地址和参数都给你了。” AJAX 线程：“……” 主线程：：“喂，AJAX 线程，你怎么不说话？” AJAX 线程：“……” 主线程：：“喂！喂喂喂！” AJAX 线程：“……” (一炷香的时间后) 主线程：：“喂！求你说句话吧！” AJAX 线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。” 正因为 JavaScript 时单线程，同步容易造成阻塞，所以，对于耗时和操作事件不确定操作，使用异步就成了必然选择。 3、异步过程一个异步过程通常时这样的： 主线程发起一个异步请求，相应的工作线程接收线程请求并告知主线程已收到；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定动作（调用回调函数）。 异步函数通常具有一下形式： 1A(arg..., callbackFn) 他可以叫做异步过程的发起函数，或者叫做异步任务注册函数。 从主线程的角度看，一个一度过程包括两个要素： 发起函数（注册函数） 回到函数 4、消息队列和事件循环异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制时怎样实现的呢？答案是利用消息队列和事件循环。 一句话概括： 工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。 消息队列：消息队列是一个先进先出的队列，放着各种消息。 事件循环：事件循环是指主线程从消息队列中取消息，执行的过程。 实际上，主线程只会做一件事，就是从消息队列里面取消息、执行消息，再去消息，再执行。当消息队列为空时，就会等待知道消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 消息队列中放的消息是什么东西？消息的具体结构当然跟具体的实现有关，可以认为： 消息就是注册异步任务时添加的回调函数。 以异步 Ajax 为例 123$.ajax('http://segmentfault.com', function(resp) &#123; console.log('我是响应：', resp);&#125;); 主线程发起 Ajax 请求后，会继续执行其他代码。Ajax 线程负责请求 segmentfault.com，拿到响应后，它会把响应封装成一个 JavaScript 对象，然后构成一条消息： 123var message = function() &#123; callbackFn();&#125; 其中 callbackFn 就是前面代码中成功响应时的回调函数。 主线程在执行完当前循环中所有代码后，就会到消息队列取出这条消息（也就是 message 函数），并执行它，到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，Ajax 线程在收到 HTTP 响应后，也就没有必要通知主线程，从而没必要往消息队列放消息。 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 5、异步与事件 消息队列中的每条消息实际上都对应着一个事件 有一类很重要的异步过程：DOM 事件 1234var button = document.getElement('#btn');button.addEventListener('click', function(e) &#123; console.log();&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。 另一方面，所有的异步过程也都可以用事件来描述。例如：setTimeout 可以看成对应一个时间到了！的事件。前文的 setTimeout(fn, 1000);可以看成： 1timer.addEventListener('timeout', 1000, fn); 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。 6、macrotasks 与 microtasks 的区别 macrotasks: setTimeout setInterval setImmediate I/O UI 渲染 microtasks: Promise process.nextTick Object.observe MutationObserver microtask 会在当前循环中执行完成,而 macrotask 会在下一个循环中执行]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简记]]></title>
    <url>%2F2018%2F07%2F27%2FGit%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git 食用手册0. 前言最近有个项目比较赶，于是决定 8 个人一个并行完成，单独把项目拿出来用 gitea 管理，没人分一个模块开发，对应也给分支，效果不过，从中也帮助自己重新温习了一下 git 的使用，小记一下。 1. 安装和使用 在 MAC 上，安装 homebrew，然后通过homebrew 安装 Git。 在 MAC 上另一种安装方法，从 AppStore 安装 Xcode，Xcode 集成了 Git，不过默认没有安装，你需要运行 Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 在 Windows 上，下载安装包，默认下一步，安装完成即可。 安装完后自报家门 12$ git config --global user.name "wuwhs"$ git config --global user.email "email@example.com" 创建版本库初始化一个 Git 仓库，使用git init命令。添加文件到 Git 仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 2. 时光穿梭 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 HEAD 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本，git log --pretty=oneline --abbrev-commit在一行显示缩写提交号。 场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景 1，第二步按场景 1 操作。 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 3. 远程仓库 创建 SSH Key。$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;。 登陆 GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容。 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git。 关联后，使用命令git push -u origin master第一次推送 master 分支的所有内容。 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 4. 分支管理 Git 鼓励大量使用分支。 查看分支：git branch。 创建分支：git branch &lt;name&gt;。 切换分支：git checkout &lt;name&gt;。 创建+切换到当前分支：git checkout -b &lt;name&gt;。 合并某分支到当前分支：git merge &lt;name&gt;。 删除分支：git branch -d &lt;name&gt;。 当 Git 无法自动合并分支时，就必须首先剞劂冲突，解决冲突后，再提交，合并完成用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fash-forward合并就看不出来曾经做过合并。 当手头工作没有完成时，先把工作现场git stash一下，然后去修复 bug，修复后，再git stash list查看历史 stash，一是用git stash apply恢复，但恢复后，stash 内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把 stash 内容也删了。 查看远程库信息，使用git remote -v。 从本地推送分支，使用git push origin branch-name，如果失败，先用git pull抓取远程的新提交。 再本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致。 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 5. 标签 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD,也可以指定一个 commit id。 git tag -a &lt;tagname&gt; -m &quot;balabala...&quot;可以指定标签信息。 git tag -s &lt;tagname&gt; -m &quot;balabala...&quot;可以用 PGP 签名标签。 命令git tag可以查看所有标签。 命令git push origin &lt;tagname&gt;可以推送一个本地标签。 命令git push origin --tags可以推送全部未推送过的本地标签。 命令git tag -d &lt;tagname&gt;可以删除一个本地标签。 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 6. 举个应用栗子 最初在远程创建项目仓库有master和develp分支，参与开发人员先在自己一个文件夹下，调出git Bash，然后输入命令git init，再把仓库git clone下来 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www$ git initInitialized empty Git repository in D:/appSoft/wampserver/wamp64/www/.git/MINGW32 /d/appSoft/wampserver/wamp64/www (master)$ git clone git@github.com:wuwhs/demo.gitCloning into 'demo'...Warning: Permanently added the RSA host key for IP address '13.229.188.59' to the list of known hosts.warning: You appear to have cloned an empty repository.Checking connectivity... done. cd demo进入clone下载的目录里，用git branch develop在本地创建一个对应的develop分支 1234567891011121314MINGW32 /d/appSoft/wampserver/wamp64/www (master)$ cd demoMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch* masterMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch developMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch develop* master 再次用git branch查看已经新建了一个develop分支 git checkout develop切换到当前develop分支 123MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git checkout developSwitched to branch 'develop' 用git pull origin develop:develop，即：git pull origin &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;，当本地和远程分支名相同时，可以简写成一个，也就是git pull origin develop，拉取远程develop分支完成，然后开发人员就可以在这个分支上工作了 123456789101112MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pull origin develop:developremote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo 7ff2cb0..7ab2842 develop -&gt; develop 7ff2cb0..7ab2842 develop -&gt; origin/developwarning: fetch updated the current branch head.fast-forwarding your working tree fromcommit 7ff2cb0627be357fa15db4e38e1bfe8fc820b8ec.Already up-to-date. 当一天了工作完成，要提交到远程分支，首先要拉取一下别人提交的代码，防止版本冲突 123456789101112MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo f848dc7..d696375 develop -&gt; origin/developUpdating f848dc7..d696375Fast-forward demo.txt | 2 ++ 1 file changed, 2 insertions(+) PS：直接偷懒pull可能会出现没有找到tracking的分支 1234567891011MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:git branch --set-upstream-to=origin/&lt;branch&gt; develop 这时候要手动添加一下对应分支依赖git branch --set-upstream-to=origin/&lt;branch&gt; develop 12345678910111213141516 MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git branch --set-upstream-to=origin/develop developBranch develop set up to track remote branch develop from origin.MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo f848dc7..d696375 develop -&gt; origin/developUpdating f848dc7..d696375Fast-forward demo.txt | 2 ++ 1 file changed, 2 insertions(+) 将本地分支提交到对应远程分支上，git push origin develop:develop，即：git push origin &lt;远程主机&gt;&lt;本地分支名&gt;:&lt;远程分支名&gt;，如果名称一样可以简写，也就是git push origin develop 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git push origin develop:developCounting objects: 9, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (9/9), 759 bytes | 0 bytes/s, done.Total 9 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To git@github.com:wuwhs/demo.git d696375..3c00c0c develop -&gt; develop 项目测试 OK 了，本地分支合并到master分支上，要用到git merge &lt;branch&gt; 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git checkout masterSwitched to branch 'master'MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git merge developUpdating c4d0377..3c00c0cFast-forward demo.txt | 9 +++++++++ 1 file changed, 9 insertions(+) 常用的操作就以上七步了，当然会有不同情形的应用。 7. 附录：git-cheat-sheet一般而言，常用的就是以上那些命令，有人专门的整理了一份比较全一点的文档 git-cheat-sheet，方便查阅。 配置列出当前配置： 1$ git config --list 列出 repository 配置： 1$ git config --local --list 列出全局配置： 1$ git config --global --list 列出系统配置： 1$ git config --system --list 设置用户名： 1$ git config --global user.name "[firstname lastname]" 设置用户邮箱： 1$ git config --global user.email "[valid-email]" 设置 git 命令输出为彩色： 1$ git config --global color.ui auto 设置 git 使用的文本编辑器设： 1$ git config --global core.editor vi 配置文件Repository 配置对应的配置文件路径[–local]： 1&lt;repo&gt;/.git/config 用户全局配置对应的配置文件路径[–global]： 1~/.gitconfig 系统配置对应的配置文件路径[–local]： 1/etc/gitconfig 创建复制一个已创建的仓库: 12# 通过 SSH$ git clone ssh://user@domain.com/repo.git 12#通过 HTTP$ git clone http://domain.com/user/repo.git 创建一个新的本地仓库: 1$ git init 本地修改显示工作路径下已修改的文件： 1$ git status 显示与上次提交版本文件的不同： 1$ git diff 把当前所有修改添加到下次提交中： 1$ git add . 把对某个文件的修改添加到下次提交中： 1$ git add -p &lt;file&gt; 提交本地的所有修改： 1$ git commit -a 提交之前已标记的变化： 1$ git commit 附加消息提交： 1$ git commit -m 'message here' 提交，并将提交时间设置为之前的某个日期: 1git commit --date="`date --date='n day ago'`" -am "Commit Message" 修改上次提交（请勿修改已发布的提交记录!） 1$ git commit --amend 修改上次提交的 committer date： 1GIT_COMMITTER_DATE="date" git commit --amend 修改上次提交的 author date： 1git commit --amend --date="date" 把当前分支中未提交的修改移动到其他分支： 123git stashgit checkout branch2git stash pop 将 stashed changes 应用到当前分支： 1git stash apply 删除最新一次的 stashed changes： 1git stash drop 搜索从当前目录的所有文件中查找文本内容： 1$ git grep "Hello" 在某一版本中搜索文本： 1$ git grep "Hello" v2.5 提交历史从最新提交开始，显示所有的提交记录（显示 hash， 作者信息，提交的标题和时间）： 1$ git log 显示所有提交（仅显示提交的 hash 和 message）： 1$ git log --oneline 显示某个用户的所有提交： 1$ git log --author="username" 显示某个文件的所有修改： 1$ git log -p &lt;file&gt; 仅显示远端分支与远端分支提交记录的差集： 1$ git log --oneline &lt;origin/master&gt;..&lt;remote/master&gt; --left-right 谁，在什么时间，修改了文件的什么内容： 1$ git blame &lt;file&gt; 显示 reflog： 1$ git reflog show 删除 reflog： 1$ git reflog delete 分支与标签列出所有的分支： 1$ git branch 列出所有的远端分支： 1$ git branch -r 切换分支： 1$ git checkout &lt;branch&gt; 创建并切换到新分支: 1$ git checkout -b &lt;branch&gt; 基于当前分支创建新分支： 1$ git branch &lt;new-branch&gt; 基于远程分支创建新的可追溯的分支： 1$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt; 删除本地分支: 1$ git branch -d &lt;branch&gt; 强制删除一个本地分支：将会丢失未合并的修改！ 1$ git branch -D &lt;branch&gt; 给当前版本打标签： 1$ git tag &lt;tag-name&gt; 给当前版本打标签并附加消息： 1$ git tag -a &lt;tag-name&gt; 更新与发布列出当前配置的远程端： 1$ git remote -v 显示远程端的信息： 1$ git remote show &lt;remote&gt; 添加新的远程端： 1$ git remote add &lt;remote&gt; &lt;url&gt; 下载远程端版本，但不合并到 HEAD 中： 1$ git fetch &lt;remote&gt; 下载远程端版本，并自动与 HEAD 版本合并： 1$ git remote pull &lt;remote&gt; &lt;url&gt; 将远程端版本合并到本地版本中： 1$ git pull origin master 以 rebase 方式将远端分支与本地合并： 1git pull --rebase &lt;remote&gt; &lt;branch&gt; 将本地版本发布到远程端： 1$ git push remote &lt;remote&gt; &lt;branch&gt; 删除远程端分支： 123$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)# orgit push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0) 发布标签: 1$ git push --tags 合并与重置(Rebase)将分支合并到当前 HEAD 中： 1$ git merge &lt;branch&gt; 将当前 HEAD 版本重置到分支中:请勿重置已发布的提交! 1$ git rebase &lt;branch&gt; 退出重置: 1$ git rebase --abort 解决冲突后继续重置： 1$ git rebase --continue 使用配置好的 merge tool 解决冲突： 1$ git mergetool 在编辑器中手动解决冲突后，标记文件为已解决冲突： 12$ git add &lt;resolved-file&gt;$ git rm &lt;resolved-file&gt; 合并提交： 1$ git rebase -i &lt;commit-just-before-first&gt; 把上面的内容替换为下面的内容： 原内容： 123pick &lt;commit_id&gt;pick &lt;commit_id2&gt;pick &lt;commit_id3&gt; 替换为： 123pick &lt;commit_id&gt;squash &lt;commit_id2&gt;squash &lt;commit_id3&gt; 撤销放弃工作目录下的所有修改： 1$ git reset --hard HEAD 移除缓存区的所有文件（i.e. 撤销上次 git add）: 1$ git reset HEAD 放弃某个文件的所有本地修改： 1$ git checkout HEAD &lt;file&gt; 重置一个提交（通过创建一个截然不同的新提交） 1$ git revert &lt;commit&gt; 将 HEAD 重置到指定的版本，并抛弃该版本之后的所有修改： 1$ git reset --hard &lt;commit&gt; 用远端分支强制覆盖本地分支： 1git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature 将 HEAD 重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改： 1$ git reset &lt;commit&gt; 将 HEAD 重置到上一次提交的版本，并保留未提交的本地修改： 1$ git reset --keep &lt;commit&gt; 删除添加.gitignore 文件前错误提交的文件： 123$ git rm -r --cached .$ git add .$ git commit -m "remove xyz file" 完~ 可参考文章： git-guide 廖雪峰 git 教程 git-scm Git Cheat Sheet 中文版]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞定css三列布局]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%90%9E%E5%AE%9Acss%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三列布局 谈到布局，首先就要想到定位，当别人问我，css 的 position 定位有哪些取值，分别表示什么意思？呃….. 定位position 有六个属性值：static、relative、absolute、fixed、sticky 和 inherit。 static（默认）：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于父级元素中。 relative：元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。 absolute：元素框不再占有文档位置，并且相对于包含块进行偏移（所谓包含块就是最近一级外层元素 position 不为 static 的元素）。 fixed：元素框不再占有文档流位置，并且相对于视窗进行定位。 sticky：css3 新增属性值，粘性定位，相当于 relative 和 fixed 的混合。最初会被当作是 relative，相对原来位置进行偏移；一旦超过一定的阈值，会被当成 fixed 定位，相对于视口定位。 三列布局三列布局，其中一列宽度自适应，在 PC 端最常用之一，搞定了三列布局，其他一样的套路。 方式一：浮动布局缺点：html 结构不正确,当包含区域宽度小于左右框之和，右边框会被挤下来 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .tree-columns-layout.float .left &#123; float: left; width: 300px; background-color: #a00; &#125; .tree-columns-layout.float .right &#123; float: right; width: 300px; background-color: #0aa; &#125; .tree-columns-layout.float .center &#123; /* left: 300px; right: 300px; */ margin: 0 300px; background-color: #aa0; overflow: auto; &#125;&lt;/style&gt;&lt;section class="tree-columns-layout float"&gt; &lt;article class="left"&gt; &lt;h1&gt;我是浮动布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class="right"&gt; &lt;h1&gt;我是浮动布局右框&lt;/h1&gt; &lt;/article&gt; &lt;article class="center"&gt; &lt;h1&gt;我是浮动布局中间框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式二：定位布局缺点：要求父级要有非 static 定位，如果没有，左右框容易偏移出去 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; .tree-columns-layout.position &#123; position: relative; &#125; .tree-columns-layout.position .left &#123; position: absolute; left: 0; top: 0; width: 300px; background-color: #a00; &#125; .tree-columns-layout.position .right &#123; position: absolute; right: 0; top: 0; width: 300px; background-color: #0aa; &#125; .tree-columns-layout.position .center &#123; margin: 0 300px; background-color: #aa0; overflow: auto; &#125;&lt;/style&gt;&lt;section class="tree-columns-layout position"&gt; &lt;article class="left"&gt; &lt;h1&gt;我是浮动定位左框&lt;/h1&gt; &lt;/article&gt; &lt;article class="center"&gt; &lt;h1&gt;我是浮动定位中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class="right"&gt; &lt;h1&gt;我是浮动定位右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式三：表格布局缺点：没什么缺点，恐惧 table 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; .tree-columns-layout.table &#123; display: table; width: 100%; &#125; .tree-columns-layout.table &gt; article &#123; display: table-cell; &#125; .tree-columns-layout.table .left &#123; width: 300px; background-color: #a00; &#125; .tree-columns-layout.table .center &#123; background-color: #aa0; &#125; .tree-columns-layout.table .right &#123; width: 300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class="tree-columns-layout table"&gt; &lt;article class="left"&gt; &lt;h1&gt;我是表格布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class="center"&gt; &lt;h1&gt;我是表格布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class="right"&gt; &lt;h1&gt;我是表格布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式四：flex 弹性布局缺点：兼容性 123456789101112131415161718192021222324252627282930313233&lt;style&gt; .tree-columns-layout.flex &#123; display: flex; &#125; .tree-columns-layout.flex .left &#123; width: 300px; flex-shrink: 0; /* 不缩小 */ background-color: #a00; &#125; .tree-columns-layout.flex .center &#123; flex-grow: 1; /* 增大 */ background-color: #aa0; &#125; .tree-columns-layout.flex .right &#123; flex-shrink: 0; /* 不缩小 */ width: 300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class="tree-columns-layout flex"&gt; &lt;article class="left"&gt; &lt;h1&gt;我是flex弹性布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class="center"&gt; &lt;h1&gt;我是flex弹性布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class="right"&gt; &lt;h1&gt;我是flex弹性布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式五：grid 栅格布局缺点：兼容性 Firefox 52, Safari 10.1, Chrome 57, Opera 44 1234567891011121314151617181920212223242526272829&lt;style&gt; .tree-columns-layout.grid &#123; display: grid; grid-template-columns: 300px 1fr 300px; &#125; .tree-columns-layout.grid .left &#123; background-color: #a00; &#125; .tree-columns-layout.grid .center &#123; background-color: #aa0; &#125; .tree-columns-layout.grid .right &#123; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class="tree-columns-layout grid"&gt; &lt;article class="left"&gt; &lt;h1&gt;我是grid栅格布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class="center"&gt; &lt;h1&gt;我是grid栅格布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class="right"&gt; &lt;h1&gt;我是grid栅格布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式六：圣杯布局缺点：需要多加一层标签，html 顺序不对，占用了布局框的 margin 属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .tree-columns-layout.cup:after &#123; clear: both; content: ""; display: table; &#125; .tree-columns-layout.cup .center &#123; width: 100%; float: left; &#125; .tree-columns-layout.cup .center &gt; div &#123; margin: 0 300px; overflow: auto; background-color: #aa0; &#125; .tree-columns-layout.cup .left &#123; width: 300px; float: left; margin-left: -100%; background-color: #a00; &#125; .tree-columns-layout.cup .right &#123; width: 300px; float: left; margin-left: -300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class="tree-columns-layout cup"&gt; &lt;article class="center"&gt; &lt;div&gt; &lt;h1&gt;我是圣杯布局中间框&lt;/h1&gt; &lt;/div&gt; &lt;/article&gt; &lt;article class="left"&gt; &lt;h1&gt;我是圣杯布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class="right"&gt; &lt;h1&gt;我是圣杯布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平且垂直居中方法（9种）]]></title>
    <url>%2F2018%2F06%2F01%2F%E6%B0%B4%E5%B9%B3%E4%B8%94%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%EF%BC%889%E7%A7%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[水平且垂直居中方法有哪些？这在实际工作中经常用到，小记一下。 演示 HTML 结构 1234567&lt;div id="div1" class="div"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt; &lt;span&gt;i&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 一般的，水平居中相对垂直居中简单很多，对于内联元素，父级元素设置text-align: center;；对于块级元素，子级元素设置margin: 0 auto;。以下结合水平居中强调实现垂直居中。 1、已知父级元素宽高，父级元素定位非 static，子级元素定位设为position: absolute/fixed，再利用margin、left和top属性居中。1234567891011121314151617#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; background-color: #ff00ff;&#125; 注：需要已知父级元素固定宽高，才能确定margin-left和margin-right。 2、子级元素是内联元素，父级元素设置line-height属性垂直居中。1234567891011121314151617#div1 &#123; width: 200px; height: 200px; line-height: 120px; text-align: center; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; line-height: normal; text-align: left; display: inline-block; background-color: #ff00ff;&#125; 注：需要已知父级元素的固定高度，才可以确定line-height。 3、子级元素是内联元素，父级元素用display: table-cell;和vertical-align: middle;属性实现垂直居中。123456789101112131415#div1 &#123; width: 200px; height: 200px; display: table-cell; text-align: center; vertical-align: middle; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; display: inline-block; background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，inline-block、table-cell不兼容 ie67 4、对于子级是块级元素，父级元素同样用display: table-cell;和vertical-align: middle;属性实现垂直居中，水平方向居中用margin: 0 auto;。1234567891011121314#div1 &#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; margin: 0 auto; background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，table-cell不兼容 ie67 5、利用 css3 translate特性：位移是基于元素宽高的。12345678910111213141516171819#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%); -moz-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，translate属性兼容 IE9+ 6、当父级是浮动的，用display: table-cell;会失效，这时需要包三层，第一层display: table;，第二层display: table-cell; 第三次居中层12345678910111213141516171819202122232425#div1 &#123; width: 200px; height: 200px; position: relative; display: table; background-color: #ffff00; float: left;&#125;#div2 &#123; width: 100%; height: 100%; display: table-cell; vertical-align: middle; /* text-align: center; */ background-color: #cccccc;&#125;#div3 &#123; width: 100px; height: 100px; margin: 0 auto; /* display: inline-block; */ background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，但 HTML 标签层数较多。 7、绝对定位加四边定位为 0。123456789101112131415161718#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; top: 0; left: 0; right: 0; bottom: 0; margin: auto; position: absolute; background-color: #cccccc;&#125; 注：无需要确定父级元素的宽高，但把定位属性全用上了 8、利用 flex 布局justify-content: center;和align-items: center;属性居中。123456789101112131415#div1 &#123; width: 200px; height: 200px; display: flex; flex-direction: row; justify-content: center; align-items: center; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; background-color: #cccccc;&#125; 注：无需要确定父级元素的宽高，兼容 IE10+ 9、利用 grid 布局，划分成 3x3 栅格，第二行第二列格子垂直水平居中12345678910111213141516#div1 &#123; width: 200px; height: 200px; display: grid; background-color: #ffff00; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);&#125;#div2 &#123; width: 100px; height: 100px; background-color: #cccccc; grid-row-start: 2; grid-column-start: 2;&#125; 注：无需要确定父级元素的宽高，兼容性 Firefox 52, Safari 10.1, Chrome 57, Opera 44]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解BFC]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFC%2F</url>
    <content type="text"><![CDATA[BFC 概念1、相关定义1.1 Formatting contextFormatting context 是 W3C CSS2.1 规定中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block formatting context（简称 BFC）和 Inline formatting context（简称 IFC）。css2.1 中只有 BFC 和 IFC，css3 中还增加了 GFC 和 FFC。 1.2 BFC 定义BFC(Block formatting context)直译为“块级格式化上下文”。它是独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。 1.3 BFC 布局规则： 内部的 Box 会在垂直方向，一个接一个地放置； Box 垂直方向地距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反）。即便存在浮动也是如此。 BFC 的区域不会与 float box 重叠。 BFC 就是页面的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素页参与计算。- 2、作用2.1 可生成 BFC 的元素 根元素 html； float 属性不为 none； position 为 absolute 或 fixed； display 为 inline-block， table-cell，table-caption，flex， inline-flex； overflow 不为 visible； 2.2 场景一：对于两栏或三栏浮动自适应布局，包含块边接触问题。12345678910111213141516171819202122232425&lt;style&gt; .left-center-right.float .left &#123; float: left; width: 200px; height: 100px; background-color: rgba(0, 0, 0, 0.7); &#125; .left-center-right.float .center &#123; background-color: rgb(13, 218, 233); height: 200px; &#125; .left-center-right.float .right &#123; float: right; width: 200px; height: 150px; background-color: rgb(189, 109, 109); &#125;&lt;/style&gt;&lt;section class="left-center-right float"&gt; &lt;article class="left"&gt;我是左边区域块&lt;/article&gt; &lt;article class="right"&gt;我是右边区域块&lt;/article&gt; &lt;article class="center"&gt;我是中间区域块&lt;/article&gt;&lt;/section&gt; 中间自适应栏边界会延展左右浮动区域 此时需要把中间栏变成 BFC 12345.left-center-right.float .center &#123; background-color: rgb(13, 218, 233); height: 200px; overflow: hidden;&#125; 2.3 场景二：子级元素有浮动，父级元素塌陷问题12345678910111213141516171819&lt;style&gt; .all-children-float .left &#123; float: left; width: 200px; height: 100px; background-color: rgba(0, 0, 0, 0.7); &#125; .all-children-float .right &#123; float: right; width: 200px; height: 150px; background-color: rgb(189, 109, 109); &#125;&lt;/style&gt;&lt;section class="all-children-float"&gt; &lt;article class="left"&gt;我是左边区域块&lt;/article&gt; &lt;article class="right"&gt;我是右边区域块&lt;/article&gt;&lt;/section&gt; 此时需要将父级元素变成 BFC 123.all-children-float &#123; position: absolute;&#125; 2.3 场景三：垂直方向 margin 出现重合12345678910111213141516171819&lt;style&gt; .verticle-block .block1 &#123; width: 200px; height: 150px; background-color: rgb(13, 218, 233); margin: 20px; &#125; .verticle-block .block2 &#123; width: 150px; height: 150px; background-color: rgb(189, 109, 109); margin: 30px; &#125;&lt;/style&gt;&lt;section class="verticle-block"&gt; &lt;article class="block1"&gt;我是区域块1&lt;/article&gt; &lt;article class="block2"&gt;我是区域块2&lt;/article&gt;&lt;/section&gt; Box 垂直方向的距离 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。 我们的做法是包一层标签，并转化成 BFC。 12345678910.wrapper1 &#123; overflow: hidden;&#125;&lt;section class="verticle-block"&gt; &lt;div class="wrapper1"&gt; &lt;article class="block1"&gt;我是区域块1&lt;/article&gt; &lt;/div&gt; &lt;article class="block2"&gt;我是区域块2&lt;/article&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css BFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的一些坑]]></title>
    <url>%2F2018%2F05%2F06%2Fcss%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[CSS 踩坑记1、如果子元素全部设置为浮动，则父元素是塌陷的 在元素末尾加块级空元素设置 clear:both； 1234.last &#123; display: block; clear: both;&#125; 在父级容器设置 before/after 模拟一个块级空元素 12345.clearfix:after &#123; content: ''; display: block; clear: both;&#125; 父级容器直接设置 overflow: auto/hidden; 2、普通文档流中块级垂直外边距合并解决办法：用 padding 代替，或改成 inline-block，或改成 float，或绝对定位 3、使用 transition 闪屏12345.demo &#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000;&#125; 过渡动画在没有启动硬件加速的情况下，会出现抖动现象，解决方案：用 translated3d、translateZ、transform 自动启动硬件加速，即改为： 1234.demo &#123; -webkit-transform: translated3d(0, 0, 0); transform: translated3d(0, 0, 0);&#125; ps:硬件加速导致 cpu 性能占用增加，电池电量消耗加大 4、超出内容用”…”表示123&lt;div class="line-clamp"&gt;来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容&lt;/div&gt; 1234567.line-clamp &#123; width: 300px; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125; 说明： -webkit-line-clamp 用来限制在一个块元素显示的文本的行数 display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 缺点：只有移动端和 webkit 浏览器支持 还不够，最后末尾最好有点渐变到”…” 12345678910111213141516.line-clamp &#123; width: 300px; line-height: 20px; height: 40px; overflow: hidden; position: relative;&#125;.line-clamp:after &#123; content: '...'; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: linear-gradient(to right, transparent, #fff 55%);&#125; 说明： 将 height 设置为 line-height 整数倍，防止超出文字露出 ie10+才支持 linear-gradient 属性 缺点： 当文字少于区域大小时，也会出现省略号 输入框 placeholder 文字带颜色1234567891011121314151617input::-webkit-input-placeholder &#123; /* WebKit browsers */ font-size: 14px; color: #009a61;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ font-size: 14px; color: #009a61;&#125;input:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ font-size: 14px; color: #009a61;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配-rem]]></title>
    <url>%2F2018%2F04%2F27%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-rem%2F</url>
    <content type="text"><![CDATA[通过封装 rem.js,动态获取屏幕宽度 通过 js 去动态计算根元素的 font-size，这样所有设备分辨率都能兼容适应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//designWidth:设计稿的实际宽度值，需要根据实际设置//maxWidth:制作稿的最大宽度值，需要根据实际设置//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750);(function(designWidth, maxWidth) &#123; var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement("style"), tid; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width &gt; maxWidth &amp;&amp; (width = maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = 'html&#123;font-size:' + rem + 'px;&#125;'; &#125; if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(remStyle); &#125; else &#123; var wrap = doc.createElement("div"); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; &#125; //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener("resize", function() &#123; clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener("pageshow", function(e) &#123; if (e.persisted) &#123; // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === "complete") &#123; doc.body.style.fontSize = "16px"; &#125; else &#123; doc.addEventListener("DOMContentLoaded", function(e) &#123; doc.body.style.fontSize = "16px"; &#125;, false); &#125;&#125;)(640, 750); 当然也可以用 media query 设置适配集中主流的屏幕尺寸 12345678910111213141516171819202122232425262728html &#123; font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123; html &#123; font-size: 25px !important; &#125;&#125;@media only screen and (min-width: 428px)&#123; html &#123; font-size: 26.75px !important; &#125;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 30px !important; &#125;&#125;@media only screen and (min-width: 569px)&#123; html &#123; font-size: 35px !important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 40px !important; &#125;&#125; 提供一个移动端 base.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175body,dl,dd,ul,ol,h1,h2,h3,h4,h5,h6,pre,form,input,textarea,p,hr,thead,tbody,tfoot,th,td &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;html &#123; -ms-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none;&#125;body &#123; line-height: 1.5; font-size: 14px;&#125;body,button,input,select,textarea &#123; font-family: 'helvetica neue', tahoma, 'hiragino sans gb', stheiti, 'wenquanyi micro hei', \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, sans-serif;&#125;b,strong &#123; font-weight: bold;&#125;i,em &#123; font-style: normal;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;table th,table td &#123; border: 1px solid #ddd; padding: 5px;&#125;table th &#123; font-weight: inherit; border-bottom-width: 2px; border-bottom-color: #ccc;&#125;img &#123; border: 0 none; width: auto\9; max-width: 100%; vertical-align: top; height: auto;&#125;button,input,select,textarea &#123; font-family: inherit; font-size: 100%; margin: 0; vertical-align: baseline;&#125;button,html input[type="button"],input[type="reset"],input[type="submit"] &#123; -webkit-appearance: button; cursor: pointer;&#125;button[disabled],input[disabled] &#123; cursor: default;&#125;input[type="checkbox"],input[type="radio"] &#123; box-sizing: border-box; padding: 0;&#125;input[type="search"] &#123; -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box;&#125;input[type="search"]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;input:focus &#123; outline: none;&#125;select[size],select[multiple],select[size][multiple] &#123; border: 1px solid #AAA; padding: 0;&#125;article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary &#123; display: block;&#125;audio,canvas,video,progress &#123; display: inline-block;&#125;body &#123; background: #fff;&#125;input::-webkit-input-speech-button &#123; display: none&#125;button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的数据驱动原理及简单实现]]></title>
    <url>%2F2017%2F09%2F10%2Fvue%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Vue双向数据绑定原理1、目标实现 理解双向数据绑定原理； 实现 &#123;&#123; &#125;&#125;、v-model和基本事件指令v-bind（:）、v-on（@）； 新增属性的双向绑定处理； 2、双向数据绑定原理vue实现对数据的双向绑定，通过对数据劫持结合发布者-订阅者模式实现的。 2.1 Object.definePropertyvue通过Object.defineProperty来实现数据劫持，会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。 1234567891011121314Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; // do something return val; &#125;, set: function(newVal) &#123; // do something &#125;&#125;); 我们可以将一些方法放到里面，从而完成对数据的监听（劫持）和视图的同步更新。 2.2 过程说明实现双向数据绑定，首先要对数据进行数据监听，需要一个监听器Observer，监听所有属性。如果属性发生变化，会调用setter和getter，再去告诉订阅者Watcher是否需要更新。由于订阅者有很多个，我们需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理。还有，我们需要一个指令解析器Complie，对每个元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或绑定相应函数。当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 3、实现ObserverObserver是一个数据监听器，核心方法是我们提到过的Object.defineProperty。如果要监听所有属性的话，则需要通过递归遍历，对每个子属性都defineProperty。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 监听器构造函数 * @param &#123;Object&#125; data 被监听数据 */function Observer(data) &#123; if (!data || typeof data !== "object") &#123; return; &#125; this.data = data; this.walk(data);&#125;Observer.prototype = &#123; /** * 属性遍历 */ walk: function(data) &#123; var self = this; Object.keys(data).forEach(function(key) &#123; self.defineReactive(data, key, data[key]); &#125;); &#125;, /** * 监听函数 */ defineReactive: function(data, key, val) &#123; observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; console.log("属性：" + key + "被监听了，现在值为：" + newVal); updateView(newVal); &#125; &#125;); updateView(val); &#125;&#125;/** * 监听器 * @param &#123;Object&#125; data 被监听对象 */function observe(data) &#123; return new Observer(data);&#125;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; // 监听数据 observe(this.data); return this;&#125;/** * 更新视图 * @param &#123;*&#125; val */function updateView(val) &#123; var $name = document.querySelector("#name"); $name.innerHTML = val;&#125;var myvm = new MyVue(&#123; el: "#demo", data: &#123; name: "hello word" &#125;&#125;); 4、实现Dep在流程介绍中，我们需要创建一个可以订阅者的订阅器Dep，主要负责手机订阅者，属性变化的时候执行相应的订阅者，更新函数。下面稍加改造Observer，就可以插入我们的订阅器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Observer.prototype = &#123; // ... /** * 监听函数 */ defineReactive: function(data, key, val) &#123; var dep = new Dep(); observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; // 判断是否需要添加订阅者 什么时候添加订阅者呢？ 与实际页面DOM有关联的data属性才添加相应的订阅者 if (Dep.target) &#123; // 添加一个订阅者 dep.addSub(Dep.target); &#125; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; console.log("属性：" + key + "被监听了，现在值为：" + newVal); // 通知所有订阅者 dep.notify(newVal); &#125; &#125;); updateView(val); // 订阅器标识本身实例 Dep.target = dep; // 强行执行getter，往订阅器中添加订阅者 var v = data[key]; // 释放自己 Dep.target = null; &#125;&#125;/** * 监听器 * @param &#123;Object&#125; data 被监听对象 */function observe(data) &#123; return new Observer(data);&#125;/** * 订阅器 */function Dep() &#123; this.subs = []; this.target = null;&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); console.log("this.subs:", this.subs); &#125;, notify: function(data) &#123; this.subs.forEach(function(sub) &#123; sub.update(data); &#125;); &#125;, update: function(val) &#123; updateView(val) &#125;&#125;;// ... PS:将订阅器Dep添加到一个订阅者设计到getter里面，是为了让Watcher初始化进行触发。 5、实现Watcher订阅者Watcher在初始化的时候需要将自己添加到订阅器Dep中，那该如何添加呢？我们已经知道监听器Observer是在get函数执行添加了订阅者Watcher的操作，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作。那么，怎样去触发get函数？很简单，只需获取对应的属性值就可以触发了，因为我们已经用Object.defineProperty监听了所有属性。vue在这里做了个技巧处理，就是咋我们添加订阅者的时候，做一个判断，判断是否是事先缓存好的Dep.target，在订阅者添加成功后，把target重置null即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// .../** * 订阅者 * @param &#123;Object&#125; vm vue对象 * @param &#123;String&#125; exp 属性值 * @param &#123;Function&#125; cb 回调函数 */function Watcher(vm, exp, cb) &#123; this.vm = vm; this.exp = exp; this.cb = cb; // 将自己添加到订阅器 this.value = this.get();&#125;Watcher.prototype = &#123; update: function() &#123; this.run(); &#125;, run: function() &#123; var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); &#125; &#125;, get: function() &#123; // 缓存自己 做个标记 Dep.target = this; // 强制执行监听器里的get函数 // this.vm.data[this.exp] 调用getter，添加一个订阅者sub，存入到全局变量subs var value = this.vm.data[this.exp]; // 释放自己 Dep.target = null; return value; &#125;&#125;;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; observe(this.data); var $name = document.querySelector("#name"); // 给name属性添加一个订阅者到订阅器中，当属性发生变化后，触发回调 var w = new Watcher(this, "name", function(val) &#123; $name.innerHTML = val; &#125;); return this;&#125; 到这里，其实已经实现了我们的双向数据绑定：能够根据初始数据初始化页面特定元素，同时当数据改变也能更新视图。 5、实现Compile步骤4整个过程都能有去解析DOM节点，而是直接固定节点进行替换。接下来我们就来实现一个解析器，完成一些解析和绑定工作。 获取页面的DOM节点，遍历存入到文档碎片对象中； 解析出文本节点，匹配&#123;&#123;&#125;&#125;（暂时只做”&#123;&#123;&#125;&#125;”的解析），用初始化数据替换，并添加相应订阅者； 分离出节点的指令v-on、v-bind和v-model，绑定相应的事件和函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262// .../** * 编译器构造函数 * @param &#123;String&#125; el 根元素 * @param &#123;Object&#125; vm vue对象 */function Compile(el, vm) &#123; this.vm = vm; this.el = document.querySelector(el); this.fragment = null; this.init();&#125;Compile.prototype = &#123; /** * 初始 */ init: function() &#123; if (this.el) &#123; console.log("this.el:", this.el); // 移除页面元素生成文档碎片 this.fragment = this.nodeToFragment(this.el); // 编译文档碎片 this.compileElement(this.fragment); this.el.appendChild(this.fragment); &#125; else &#123; console.log("DOM Selector is not exist"); &#125; &#125;, /** * 页面DOM节点转化成文档碎片 */ nodeToFragment: function(el) &#123; var fragment = document.createDocumentFragment(); var child = el.firstChild; // 此处添加打印，出来的不是页面中原始的DOM，而是编译后的？ // NodeList是引用关系，在编译后相应的值被替换了，这里打印出来的NodeList是后来被引用更新了的 console.log("el:", el); // console.log("el.firstChild:", el.firstChild.nodeValue); while (child) &#123; // append后，原el上的子节点被删除了，挂载在文档碎片上 fragment.appendChild(child); child = el.firstChild; &#125; return fragment; &#125;, /** * 编译文档碎片，遍历到当前是文本节点则去编译文本节点，如果当前是元素节点，并且存在子节点，则继续递归遍历 */ compileElement: function(fragment) &#123; var childNodes = fragment.childNodes; var self = this; [].slice.call(childNodes).forEach(function(node) &#123; // var reg = /\&#123;\&#123;\s*(.+)\s*\&#125;\&#125;/g; var reg = /\&#123;\&#123;\s*((?:.|\n)+?)\s*\&#125;\&#125;/g; var text = node.textContent; if (self.isElementNode(node)) &#123; self.compileAttr(node); &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; reg.lastIndex = 0 /* var match; while(match = reg.exec(text)) &#123; self.compileText(node, match[1]); &#125; */ self.compileText(node, reg.exec(text)[1]); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node); &#125; &#125;); &#125;, /** * 编译属性 */ compileAttr: function(node) &#123; var nodeAttrs = node.attributes; var self = this; Array.prototype.forEach.call(nodeAttrs, function(attr) &#123; var attrName = attr.name; // 只对vue本身指令进行操作 if (self.isDirective(attrName)) &#123; var exp = attr.value; // v-on指令 if (self.isOnDirective(attrName)) &#123; self.compileOn(node, self.vm, exp, attrName); &#125; // v-bind指令 if(self.isBindDirective(attrName)) &#123; self.compileBind(node, self.vm, exp, attrName); &#125; // v-model else if (self.isModelDirective(attrName)) &#123; self.compileModel(node, self.vm, exp, attrName); &#125; node.removeAttribute(attrName); &#125; &#125;) &#125;, /** * 编译文档碎片节点文本，即对标记替换 */ compileText: function(node, exp) &#123; var self = this; var exps = exp.split("."); var initText = this.vm.data[exp]; // 初始化视图 this.updateText(node, initText); // 添加一个订阅者到订阅器 var w = new Watcher(this.vm, exp, function(val) &#123; self.updateText(node, val); &#125;); &#125;, /** * 编译v-on指令 */ compileOn: function(node, vm, exp, attrName) &#123; // @xxx v-on:xxx var onRE = /^@|^v-on:/; var eventType = attrName.replace(onRE, ""); var cb = vm.methods[exp]; if (eventType &amp;&amp; cb) &#123; node.addEventListener(eventType, cb.bind(vm), false); &#125; &#125;, /** * 编译v-bind指令 */ compileBind: function (node, vm, exp, attrName) &#123; // :xxx v-bind:xxx var bindRE = /^:|^v-bind:/; var attr = attrName.replace(bindRE, ""); var val = vm.data[exp]; node.setAttribute(attr, val); &#125;, /** * 编译v-model指令 */ compileModel: function(node, vm, exp, attrName) &#123; var self = this; var val = this.vm.data[exp]; // 初始化视图 this.modelUpdater(node, val); // 添加一个订阅者到订阅器 new Watcher(this.vm, exp, function(value) &#123; self.modelUpdater(node, value); &#125;); // 绑定input事件 node.addEventListener("input", function(e) &#123; var newVal = e.target.value; if (val === newVal) &#123; return; &#125; self.vm.data[exp] = newVal; // val = newVal; &#125;); &#125;, /** * 更新文档碎片相应的文本节点 */ updateText: function(node, val) &#123; node.textContent = typeof val === "undefined" ? "" : val; &#125;, /** * model更新节点 */ modelUpdater: function(node, val, oldVal) &#123; node.value = typeof val == "undefined" ? "" : val; &#125;, /** * 属性是否是vue指令，包括v-xxx:,:xxx,@xxx */ isDirective: function(attrName) &#123; var dirRE = /^v-|^@|^:/; return dirRE.test(attrName); &#125;, /** * 属性是否是v-on指令 */ isOnDirective: function(attrName) &#123; var onRE = /^v-on:|^@/; return onRE.test(attrName); &#125;, /** * 属性是否是v-bind指令 */ isBindDirective: function (attrName) &#123; var bindRE = /^v-bind:|^:/; return bindRE.test(attrName); &#125;, /** * 属性是否是v-model指令 */ isModelDirective: function(attrName) &#123; var mdRE = /^v-model/; return mdRE.test(attrName); &#125;, /** * 判断元素节点 */ isElementNode: function(node) &#123; return node.nodeType == 1; &#125;, /** * 判断文本节点 */ isTextNode: function(node) &#123; return node.nodeType == 3; &#125;&#125;;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; this.methods = options.methods; observe(this.data); new Compile(options.el, this.vm); return this;&#125; 这样我们就可以调用指令v-bind、v-on和v-model。 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;style&gt; .red &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt; &lt;h2 v-bind:class="myColor"&gt;&amp;#123;&amp;#123; name &amp;#125;&amp;#125;&lt;/h2&gt; &lt;input type="text" name="" v-model="name"&gt; &lt;button @click="clickOk"&gt;Ok&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var myvm = new MyVue(&#123; el: "#demo", data: &#123; name: "hello word", myColor: "red" &#125;, methods: &#123; clickOk: function() &#123; alert("I am OK"); &#125; &#125;&#125;);setTimeout(function() &#123; myvm.data.name = "wawawa...vue was born";&#125;, 2000);&lt;/script&gt; 5、其他5.1 proxy代理data可能注意到了，我们不管是在赋值还是取值，都是在myvm.data.someAttr上操作的，而在vue上我们习惯直接myvm.someAttr这种形式。怎样实现呢？同样，我们可以用Object.defineProperty对data所有属性做一个代理，即访问vue实例属性时，代理到data上。很简单，实现如下： 1234567891011121314151617/** * 将数据拓展到vue的根，方便读取和设置 */MyVue.prototype.proxy = function(key) &#123; var self = this; Object.defineProperty(this, key, &#123; enumerable: true, configurable: true, get: function proxyGetter() &#123; return self.data[key]; &#125;, set: function proxySetter(newVal) &#123; self.data[key] = newVal; &#125; &#125;);&#125; 5.2 parsePath上面对于data的操作只是到对于简单的基本类型属性，对于对象属性的改变该怎么更新到位呢？其实，只要深度遍历对象属性路径，就可以找到要访问属性值。 12345678910111213141516171819/** * 根据对象属性路径，最终获取值 * @param &#123;Object&#125; obj 对象 * @param &#123;String&#125; path 路径 * return 值 */function parsePath(obj, path) &#123; var bailRE = /[^\w.$]/; if (bailRE.test(path)) &#123; return &#125; var segments = path.split('.'); for (var i = 0; i &lt; segments.length; i++) &#123; if (!obj) &#123; return &#125; obj = obj[segments[i]]; &#125; return obj;&#125; 用这个方法替换我们的所有取值操作vm[exp] =&gt; parsePath(vm, exp) 6、新增属性的双向数据绑定6.1 给对象添加属性Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。也就是我们需要在Vue原型上添加一个set方法去设置新添加的属性，新属性同样要进行监听和添加订阅者。 123456789101112131415161718192021222324252627282930313233/** * vue的set方法，用于外部新增属性 Vue.$set(target, key, val) * @param &#123;Object&#125; target 数据 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; val 值 */function set(target, key, val) &#123; if (Array.isArray(target)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val; &#125; if (target.hasOwnProperty(key)) &#123; target[key] = val; return val &#125; var ob = (target).$Observer; if (!ob) &#123; target[key] = val; return val &#125; // 对新增属性定义监听 ob.defineReactive(target, key, val); ob.dep.notify(); return val;&#125;MyVue.prototype.$set = set; 6.1 给数组对象添加属性把数组看成一个特殊的对象，就很容易理解了，对于unshift、push和splice变异方法是添加了对象的属性的，需要对新加的属性进行监听和添加订阅者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var arrKeys = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];var extendArr = [];arrKeys.forEach(function(key) &#123; def(extendArr, key, function() &#123; var result, arrProto = Array.prototype, ob = this.$Observer, arr = arrProto.slice.call(arguments), inserted, index; switch (key) &#123; case "push": inserted = arr; index = this.length; break; case "unshift": inserted = arr; index = 0; break; case "splice": inserted = arr.slice(2); index = arr[0]; break; &#125; result = arrProto[key].apply(this, arguments); // 监听新增数组对象属性 if (inserted) &#123; ob.observeArray(inserted); &#125; ob.dep.notify(); return result; &#125;);&#125;);var arrayKeys = Object.getOwnPropertyNames(extendArr);/** * 监听器构造函数 * @param &#123;Object&#125; data 被监听数据 */function Observer(data) &#123; this.dep = new Dep(); if (!data || typeof data !== "object") &#123; return; &#125; // 在每个object上添加一个observer def(data, "$Observer", this); // 继承变异方法 if (Array.isArray(data)) &#123; // 把数组变异方法的处理，添加到原型链上 data.__proto__ = extendArr; // 监听数组对象属性 this.observeArray(data); &#125; else &#123; this.data = data; this.walk(data); &#125;&#125;Observer.prototype = &#123; // ... /** * 监听数组 */ observeArray: function(items) &#123; console.log("items:", items); for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli中遇到的坑]]></title>
    <url>%2F2017%2F09%2F02%2Fvue-cli%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Vue-cli 脚手架项目构建自动化，错误查起来越来越不知所措，坑很多，踩过后要记录，防止踩第二遍 vue 单文件@import css 文件，不加~会报错 123&lt;style lang="stylus" scoped&gt;@import 'assets/css/variable'&lt;/style&gt; 报错： 12345678910[HMR] bundle has 1 errors172:176 ./~/css-loader?&#123;"minimize":false,"sourceMap":false&#125;!./~/vue-loader/lib/style-compiler?&#123;"vue":true,"id":"data-v-be4708e4","scoped":true,"hasInlineConfig":false&#125;!./~/stylus-loader?&#123;"sourceMap":false&#125;!./~/vue-loader/lib/selector.js?type=styles&amp;index=0!./src/components/views/programs/Programs.vueModule build failed: Error: D:\appSoft\wampserver\wamp64\www\iHomed_vue\src\components\views\programs\Programs.vue:200:9 196| &#125; 197| &lt;/script&gt; 198| 199| &lt;style lang="stylus" scoped&gt; 200| @import 'assets/css/variable'----------------^ 201| 正确写法@import &#39;~assets/css/variable&#39; vue-cli 中 config/index.js 配置说明1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; build: &#123; env: require('./prod.env'), // 使用 config/prod.env.js 中定义的编译环境 index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的 index.html 文件 assetsRoot: path.resolve(__dirname, '../dist'), // 编译输出的静态资源路径 assetsSubDirectory: 'static', // 编译输出的二级目录 assetsPublicPath: '/', // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 productionSourceMap: true, // 是否开启 cssSourceMap // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, // 是否开启 gzip productionGzipExtensions: ['js', 'css'], // 需要使用 gzip 压缩的文件扩展名 // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;, dev: &#123; // dev 环境 env: require('./dev.env'), // 使用 config/dev.env.js 中定义的编译环境 port: 8084, // 运行测试页面的端口 autoOpenBrowser: true, // 自动在浏览器中打开 assetsSubDirectory: 'static', // 编译输出的二级目录 assetsPublicPath: '/', // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 proxyTable: &#123;&#125;, // 需要 proxyTable 代理的接口（可跨域） // CSS Sourcemaps off by default because relative paths are "buggy" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false // 是否开启 cssSourceMap &#125;&#125; 曾经不易理解的两点assetsSubDirectory和assetsPublicPath assetsSubDirectory被 webpack 编译处理过的资源文件都会在这个 build.assetsRoot 目录下，如果 assetsRoot 值是&quot;/web/app&quot;，assetsSubDirectory 值为&quot;static&quot;，那么，webpack 将把所有资源编译到web/app/static目录下 assetsPublicPath这个是通过 http 服务器运行的 url 路径，大多数情况下，这个是根目录（/）。如果你的后台框架对静态资源 url 前缀有要求，你仅需改变这个参数。比如不用本地的，而用线上的 CDN。 父子组件嵌套，各个钩子函数触发顺序偶然看到这个问题：vue 中父子组件各个钩子函数触发顺序是怎样的？一时还真背问到了，在项目中添加打印才发现是这样子的 顺序是：先依次触发父级组件beforeCreate、create和beforeMounte，再依次触发子级组件beforeCreate、create、beforeMounte和mounted，最后父级组件mounted 父子组件之间通信，兄弟组件之间通信这个问题基本清晰，在这归纳一下 1. 父组件数据传给子组件通过props属性传递 12&lt;!--父组件--&gt;&lt;parent-component :parent-data="pdata"&gt;&lt;/parent-component&gt; 123456789// 子组件export default &#123; props: &#123; parentData: &#123; type: String, default: '' &#125; &#125;&#125; 2. 子组件传数据给父组件使用$emit派发 12&lt;!--父组件--&gt;&lt;parent-component :parent-data:sync="pdata" @handle-callback="handlerCallback"&gt;&lt;/parent-component&gt; 12345678// 父组件export default &#123; methods: &#123; handlerCallback(params) &#123; // do something &#125; &#125;&#125; 12345678910// 子组件export default &#123; created() &#123; // ... this.$emit('handleCallback', params) // ... this.$emit('update:parentData', someData) &#125;&#125; 3. 兄弟组件数据传递 对于大型项目，用 vue 官方推荐的 vuex EventBus 提取 bus.js 123import Vue from 'vue'const bus = new Vue()export default bus 兄弟组件 1 发送数据 12345678import bus from './bus'export default &#123; created() &#123; // ... this.$emit('busEvent1', someData) &#125;&#125; 兄弟组件 2 接收数据 12345678910import bus from './bus'export default &#123; created() &#123; // ... this.$on('busEvent1', function(data) &#123; console.log(data) &#125;) &#125;&#125; 子组件 A $emit派发某个事件，再由父组件@handle-callback=&quot;handlerCallback&quot;监听获取数据，然后，父组件$refs直接访问到子组件 B 的方法，从而间接实现从子组件 A 到子组件 B 的数据传递 props 在子组件中被重写报错1vue.esm.js?06e7:591 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "isShow" 解决方案props传过来的参数通过Vue.$emit提交修改 在props和data中使用this在 Vue2.2.2 或更高版本才能这样使用，低于这个版本时，注入的值会在props和data初始化之后得到。 对于高阶插件/组件库，解决组件与其子孙组件数据传输问题 解决方案一：$attrs和$listener 使用属性和方法不通过props传递，在子孙组件中直接用$attrs和$listeners接收。不过支持 v2.4.0+。 1234567891011121314151617181920// 父级组件&lt;ul id="app6"&gt; &lt;item class="item" :model="treeData" :count="123" @abc="function()&#123;&#125;" &gt;&lt;/item&gt;&lt;/ul&gt;// 子孙组件inheritAttrs: false,created () &#123; let attrs = this.$attrs; console.log('mode:', attrs.mode); console.log('count:', attrs.count); let listeners = this.$listeners; console.log('bac:', listeners.abc);&#125; 解决方案二：provide/inject 父级组件传入provide数据选项，子孙组件注入inject数据。 1234567// 父组件provide: &#123; foo: 'bar'&#125;// 子孙组件inject: ['foo'] // or inject: &#123; name: 'foo', defult: '' &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
</search>
