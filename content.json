{"meta":{"title":"little ice's Blog","subtitle":"选择比努力更重要","description":"小小前端er一枚,擅长各项前端技能，深入研究移动端开发与前端性能","author":"Little ice","url":"https://leekiwi.github.io"},"pages":[{"title":"分类 & 标签","date":"2015-10-12T13:49:10.000Z","updated":"2016-07-24T16:05:40.000Z","comments":true,"path":"tags/index.html","permalink":"https://leekiwi.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2018-09-10T07:06:28.915Z","updated":"2018-09-10T07:06:28.915Z","comments":false,"path":"/404.html","permalink":"https://leekiwi.github.io//404.html","excerpt":"","text":".article-title { font-size: 2.1em; } strong a { color: #747474; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } .share, #page-visit, .visit span:nth-child(2), .pic br { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } 很抱歉，您所访问的地址并不存在: 回主页 · 所有文章 · 留言板 可在边栏搜索框中对本站进行检索，以获取相关信息。 以下是博主喜欢的一些歌曲，可以听听，稍作休息~"},{"title":"关于我 & 留言板","date":"2016-09-30T12:31:36.000Z","updated":"2018-09-10T13:39:41.396Z","comments":true,"path":"about/index.html","permalink":"https://leekiwi.github.io/about/index.html","excerpt":"","text":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 2016 年 8 月，毕业一年后，终于明确了自己真正所热衷的事，并找到了与之匹配的职业 —— Web 前端工程师。为能如愿转职，开始利用业余时间，努力钻研，希望这一天尽早到来！ —— Little ice, 2016年9月30日 开博缘由: 在建立改造博客网站的过程中，学习和巩固前端基本知识；通过写博客的方式，加深理解，显性化自己的隐性知识；共享知识，吸引同好，交流进步。 文章-博客站点建设历程: 本篇日志用于归纳记录自己在学习建设个人博客站点中的各种尝试和思考。为方便编辑和查看最新进展，更新以倒序方式呈现。 文章-个人 Web 前端学习路线: 简单记录个人学习 Web 前端过程中使用的教程和书籍。仅列出较系统和专业化的资料，不包括网上零散的文章和教程。 博客主题: 博客目前使用的是自己改的主题 Yelee，介绍请转主题 GitHub 页面，欢迎 Star 和提 issue。 欢迎交流: 个人邮件及社交网站等信息见边栏底部；有什么留言或问题直接在文末留下评论即可。"}],"posts":[{"title":"","slug":"新增功能","date":"2018-09-11T08:21:03.098Z","updated":"2018-09-11T08:21:03.098Z","comments":true,"path":"2018/09/11/新增功能/","link":"","permalink":"https://leekiwi.github.io/2018/09/11/新增功能/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-09-10T06:39:42.010Z","updated":"2018-09-10T10:07:41.199Z","comments":true,"path":"2018/09/10/hello-world/","link":"","permalink":"https://leekiwi.github.io/2018/09/10/hello-world/","excerpt":"Hexo 使用说明Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Hexo 使用说明Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"ES6中简约强大数组操作组合","slug":"ES6中简约强大数组操作组合","date":"2018-09-07T10:25:20.000Z","updated":"2018-09-10T10:18:54.442Z","comments":true,"path":"2018/09/07/ES6中简约强大数组操作组合/","link":"","permalink":"https://leekiwi.github.io/2018/09/07/ES6中简约强大数组操作组合/","excerpt":"ES6 数组新增方法reducearray.reduce(callback[, initialValue])","text":"ES6 数组新增方法reducearray.reduce(callback[, initialValue]) 数组求和 12345const numbers = [10, 20, 30, 40]numbers.reduce((prev, cur, index, arr) =&gt; &#123; console.log('prev: ' + prev + '; ' + 'cur: ' + cur + ';') return prev + cur&#125;) 123456prev: 10cur: 20prev: 30cur: 30prev: 60cur: 40 这第二个参数就是设置 prev 的初始类型和初始值，比如为 0，就表示 prev 的初始值为 number 类型，值为 0，因此，reduce 的最终结果也会是 number 类型。 12345const numbers = [10, 20, 30, 40]numbers.reduce((prev, cur, index, arr) =&gt; &#123; console.log('prev: ' + prev + '; ' + 'cur: ' + cur + ';') return prev + cur&#125;, 0) 12345678prev: 0cur: 10prev: 10cur: 20prev: 30cur: 30prev: 60cur: 40 参考： https://www.zhangxinxu.com/wordpress/2013/04/es5%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/ https://segmentfault.com/a/1190000005921341 https://segmentfault.com/a/1190000013972464 https://segmentfault.com/a/1190000013121115","categories":[{"name":"ES6","slug":"ES6","permalink":"https://leekiwi.github.io/categories/ES6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://leekiwi.github.io/tags/javascript/"}]},{"title":"干掉状态从session到token","slug":"干掉状态从session到token","date":"2018-09-07T08:00:30.000Z","updated":"2018-09-08T17:02:26.920Z","comments":true,"path":"2018/09/07/干掉状态从session到token/","link":"","permalink":"https://leekiwi.github.io/2018/09/07/干掉状态从session到token/","excerpt":"美好的旧时光我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。 上班的时候偶尔有些 HTTP 的请求发到我这里， 我简单的看一下， 取出相对应的 html 文档，图片，发回去就可以了， 然后就可以继续喝茶聊天。","text":"美好的旧时光我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。 上班的时候偶尔有些 HTTP 的请求发到我这里， 我简单的看一下， 取出相对应的 html 文档，图片，发回去就可以了， 然后就可以继续喝茶聊天。 我的创造者们对我很好， 他们制定的一个简单 HTTP 协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了 HTTP 请求， 每个请求对我来说都是全新的！ 邮件服务器很羡慕我， 他说：老弟，你的生活太惬意了， 哪像我， 每次有人从客户端访问邮箱， 我都得专门给他建立一个会话， 来处理他发的消息， 你倒好， 完全不用管理会话。 这是由应用的特性决定的， 如果邮件服务器不管理会话， 那多个人之间的邮件消息就会完全混到一起了， 乱作一团了。 而 30 年前的 Web 基本上就是文档的浏览而已， 既然是浏览，我作为一个服务器， 为什么要记住谁在一段时间里都浏览了什么文档呢？ 2 Session但是好日子没持续多久， 很快大家就不满足于静态的 Html 文档了， 交互式的 Web 应用开始兴起， 尤其是论坛， 在线购物等网站。 我马上就遇到了和邮件服务器一样的问题， 那就是必须管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放了商品， 也就是说我必须把每个人区分开。 这对我来说是个不小的挑战， 由于 HTTP 协议的无状态特性， 我必须加点小手段，才能完成会话管理。 我想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字符串，每个人收到的都不一样， 每次大家向我发起 HTTP 请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了。 3 沉重的负担大家都很高兴， 可是我就不爽了。 每个人只需要保存自己的 session id，而我需要保存所有人的 session id ！ 如果访问我的人多了， 就得由成千上万，甚至几十万个。 这对我来说是一个巨大的开销 ， 严重的限制了我的扩展能力， 比如说我用两个机器组成了一个集群， 小 F 通过机器 A 登录了系统， 那 session id 会保存在机器 A 上， 假设小 F 的下一次请求被转发到机器 B 怎么办？ 机器 B 可没有小 F 的 session id 啊。 有时候我会采用一点小伎俩： session sticky ， 就是让小 F 的请求一直粘连在机器 A 上， 但是这也不管用， 要是机器 A 挂掉了， 还得转到机器 B 去。 那我只好做 session 的复制了， 把 session id 在两个机器之间搬来搬去， 快累死了。 后来有个叫 Memcached 的给我支了招： 把 session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责 session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。 我也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的 session 对我来说是一个沉重的负担。 4 时间换空间这几天的晚上我一直在思考， 我为什么要保存这可恶的 session 呢， 只让每个客户端去保存该多好？ 可是如果我不保存这些 session id , 我怎么验证客户端发给我的 session id 的确是我生成的呢？ 如果我不去验证，我都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造 session id , 为所欲为了。 嗯，对了，关键点就是验证 ！ 比如说， 小 F 已经登录了系统， 我给他发一个 令牌(token)， 里边包含了小 F 的 user id， 下一次小 F 再次通过 Http 请求访问我的时候， 把这个 token 通过 Http header 带过来不就可以了。 不过这和 session id 没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。 那就对数据做一个签名吧， 比如说我用 HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为 token ， 由于密钥别人不知道， 就无法伪造 token 了。 这个 token 我不保存， 当小 F 把这个 token 给我发过来的时候，我再用同样的 HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和 token 中的签名做个比较， 如果相同， 我就知道小 F 已经登录过了，并且可以直接取到小 F 的 user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用 Base64 做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。 当然， 如果一个人的 token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的 session id 被别人偷走是一样的。 这样一来， 我就不保存 session id 了， 我只是生成 token , 然后验证 token ， 我用我的 CPU 计算时间获取了我的 session 存储空间 ！ 解除了 session id 这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！ （完）","categories":[{"name":"状态保持","slug":"状态保持","permalink":"https://leekiwi.github.io/categories/状态保持/"}],"tags":[{"name":"http","slug":"http","permalink":"https://leekiwi.github.io/tags/http/"}]},{"title":"element-ui更换主题和按需引入组件","slug":"element-ui更换主题和按需引入组件","date":"2018-09-04T11:40:30.000Z","updated":"2018-09-10T10:17:13.094Z","comments":true,"path":"2018/09/04/element-ui更换主题和按需引入组件/","link":"","permalink":"https://leekiwi.github.io/2018/09/04/element-ui更换主题和按需引入组件/","excerpt":"element-ui 使用初体验前言手上有些项目用的element-ui，刚好有空琢磨一下怎么减小打包文件大小和打包速度方面，为了演示实验，用 vue-cli 生成初始项目，在这仅对 element-ui 主题和组件方面来优化。","text":"element-ui 使用初体验前言手上有些项目用的element-ui，刚好有空琢磨一下怎么减小打包文件大小和打包速度方面，为了演示实验，用 vue-cli 生成初始项目，在这仅对 element-ui 主题和组件方面来优化。 1vue init webpack vuecli 完整引入完整地将 ui 和样式引入。 12import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css' 在页面简单使用三个组件，看看效果。 1234567891011121314&lt;div class=\"block\"&gt; &lt;span class=\"demonstration\"&gt;区分颜色&lt;/span&gt; &lt;el-rate v-model=\"value1\" :colors=\"['#99A9BF', '#F7BA2A', '#FF9900']\"&gt; &lt;/el-rate&gt;&lt;/div&gt;&lt;el-button type=\"primary\" icon=\"el-icon-edit\"&gt;&lt;/el-button&gt;&lt;el-row&gt; &lt;el-button icon=\"el-icon-search\" circle&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" icon=\"el-icon-edit\" circle&gt;&lt;/el-button&gt; &lt;el-button type=\"success\" icon=\"el-icon-check\" circle&gt;&lt;/el-button&gt; &lt;el-button type=\"info\" icon=\"el-icon-message\" circle&gt;&lt;/el-button&gt; &lt;el-button type=\"warning\" icon=\"el-icon-star-off\" circle&gt;&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" circle&gt;&lt;/el-button&gt;&lt;/el-row&gt; 再看一下打包后的资源大小情况npm run build --report。 1234567891011121314Hash: fa47514a97341329a7c0Version: webpack 3.11.0Time: 20363ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/vendor.5efcf828140d5dbedda9.js 714 kB 0 [emitted] [big] vendor static/js/app.a4a31db472f653b911e7.js 12 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.f24bb0ae3686720fe2e00c5a2024b8f1.css 185 kB 1 [emitted] appstatic/css/app.f24bb0ae3686720fe2e00c5a2024b8f1.css.map 267 kB [emitted] static/js/vendor.5efcf828140d5dbedda9.js.map 2.73 MB 0 [emitted] vendor static/js/app.a4a31db472f653b911e7.js.map 22.8 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] 发现打包后提取公共模块static/js/vendor.js有 714kb 再看一下各个模块占用情况： 发现elment-ui.common.js占用最大。所有模块资源总共有 708kb。怎么才能减小打包后的大小呢？很容易就会想到 ui 的引入和样式的引入中，实际我们只使用了三个组件，却整体都被打包了，在这里引入这三个组件即可。 按需引入组件样式新建一个element-variables.scss文件（为什么是 SCSS 文件，后面自定义主题会用到）。 12345678/*icon字体路径变量*/$--font-path: &quot;~element-ui/lib/theme-chalk/fonts&quot;;/*按需引入用到的组件的scss文件和基础scss文件*/@import &quot;~element-ui/packages/theme-chalk/src/base.scss&quot;;@import &quot;~element-ui/packages/theme-chalk/src/rate.scss&quot;;@import &quot;~element-ui/packages/theme-chalk/src/button.scss&quot;;@import &quot;~element-ui/packages/theme-chalk/src/row.scss&quot;; 按需引入组件新建一个elementConfig.js文件，将项目用到的 element 组件引入。 123456789import &#123; Rate, Row, Button &#125; from 'element-ui'export default &#123; install(V) &#123; V.use(Rate) V.use(Button) V.use(Row) &#125;&#125; 第一次优化后打包分析将以上element-variables.scss和elementConfig.js引入到main.js中。 1234import ElementUI from '@/assets/js/elementConfig'import '@/assets/css/element-variables.scss'Vue.use(ElementUI) 貌似上面一切都很顺理成章，打包后大小会减小。 1234567891011121314Hash: 3ba9b74482f121efd3aaVersion: webpack 3.11.0Time: 18854ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/vendor.11c71f168a2d61b547a0.js 714 kB 0 [emitted] [big] vendor static/js/app.dbb5b49dad2d42b3598c.js 11.2 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.bf52525d6279e7fb87b4db770d119a8d.css 25.7 kB 1 [emitted] appstatic/css/app.bf52525d6279e7fb87b4db770d119a8d.css.map 63 kB [emitted] static/js/vendor.11c71f168a2d61b547a0.js.map 2.73 MB 0 [emitted] vendor static/js/app.dbb5b49dad2d42b3598c.js.map 21 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] 结果可知，static/js/vendor.js还是 714kb！ 再看各个模块占用情况： WHAT?竟然模块都没什么变化，岂不是竹篮打水，事与愿违。 再次打包优化尝试后来查到有人同样遇到这个问题，提出一个issues#6362，原来只引入需要的element-ui组件，webpack还是把整体的 ui 库和样式都打包了，需要一个webpack的babel插件babel-plugin-component，这样才能真正按需引入打包。这块其实被写到官方文档更换 自定义主题 的配置了。 于是npm i babel-pugin-componet -D安装后，在增加.babelrc文件插件配置 123456789101112131415&#123; \"presets\": [ [\"env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;], \"stage-2\" ], \"plugins\": [\"transform-vue-jsx\", \"transform-runtime\", [\"component\", &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" &#125;]]&#125; 页面运行正常，再次打包。 1234567891011121314Hash: 9cc71dead6d7646c9ed4Version: webpack 3.11.0Time: 9963ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/app.77c0883f4f0fc0bf5cbc.js 11.4 kB 0 [emitted] app static/js/vendor.942130fd13274b901889.js 126 kB 1 [emitted] vendor static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.b140020e5dbee406ae70780b43ba7ddc.css 27.8 kB 0 [emitted] appstatic/css/app.b140020e5dbee406ae70780b43ba7ddc.css.map 91.4 kB [emitted] static/js/app.77c0883f4f0fc0bf5cbc.js.map 21.1 kB 0 [emitted] app static/js/vendor.942130fd13274b901889.js.map 613 kB 1 [emitted] vendor static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] static/js/vendor.js确实变小了，126kB。再来看各个模块分析图。 模块总共 135.03KB，少了 5 倍！ 更换主题element-ui的theme-chalk使用SCSS编写，如果在自己的项目中也是用SCSS，那么可以直接在项目中改变样式变量，因此可以在前面新建的element-variables.scss文件用新的主题颜色变量覆盖即可。 12345/*主题颜色变量*/$--color-primary: #f0f;/*icon字体路径变量*/$--font-path: &quot;~element-ui/lib/theme-chalk/fonts&quot;; 可能你已经注意到了，这里没有分别引入用到的组件样式了，是因为babel-plugin-component帮我们按需引入了对应的样式。 现在我们的主题就变成了 如果你没有用到SCSS，可以用element-theme主题编译插件，生成自定义主题文件引入。 完~ps：个人见解有限，欢迎指正。","categories":[{"name":"vue","slug":"vue","permalink":"https://leekiwi.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://leekiwi.github.io/tags/vue/"},{"name":"element-ui","slug":"element-ui","permalink":"https://leekiwi.github.io/tags/element-ui/"}]},{"title":"前端必备vscode插件","slug":"前端必备vscode插件","date":"2018-09-03T01:00:30.000Z","updated":"2018-09-08T17:02:12.323Z","comments":true,"path":"2018/09/03/前端必备vscode插件/","link":"","permalink":"https://leekiwi.github.io/2018/09/03/前端必备vscode插件/","excerpt":"前言这篇文章只要让你做一些基础的配置，把 vscode 变得更加顺手；插件的需求不是一成不变，有些插件我已经移除了。。在最新的 VSCODE 1.9.1 中，部分以前用插件实现的功能已经集成了，那就没有必要存在了。这里就不做推荐了复制代码","text":"前言这篇文章只要让你做一些基础的配置，把 vscode 变得更加顺手；插件的需求不是一成不变，有些插件我已经移除了。。在最新的 VSCODE 1.9.1 中，部分以前用插件实现的功能已经集成了，那就没有必要存在了。这里就不做推荐了复制代码 必备插件 功能性 Auto Close Tag : 匹配标签，关闭对应的标签。很实用【HTML/XML】 Auto Rename Tag : sublime 和 webstorm 也有这个内置功能，改变标签的时候同时改动开闭合标签；【HTML/XML】 beautify : 良好的拓展性，可以格式化 JSON|JS|HTML|CSS|SCSS,比内置格式化好用 Code Runner : 代码编译运行看结果，支持众多语言 colorize : 会给颜色代码增加一个当前匹配代码颜色的背景，非常好 Document This : JSDOC 注解调用，值得易用 Git History : 不得不赞的插件，谁用谁知道，功能很赞 HTML CSS Support : 这个也是必备插件之一 Path Autocomplete : 路径智能补全 Path Intellisense ： 路径智能提示 SCSS IntelliSense Preview : SCSS 智能提醒，配置强大 Syncing: 这个同步插件要比官方市场那个最高下载量的要好，支持删除同步！！！ Version Lens : 可以及时看到 package.json 内部版本的变动，很实用 Output Colorizer : 可以终端日志输出着色，实用 代码片段插件12JavaScript (ES6) code snippets : ES6的代码片段，实用JavaScript Snippet Pack : ES5及以下的代码片段，实用 语法校验1stylelint : 比内置的要全，更智能 主题 Panda:用了相当久的一套颜色高亮，个人感觉很耐看 Enki Theme (Material Design Inspired) : 当前用的代码高亮，个人感觉很赞 Material Icon Theme : 一套扁平化的文件图标，内置的 seti 也很优秀，还有 simple icon 和 vscode-icons 作者：爱吃 kiwi链接：https://leekiwi.github.io/来源：github著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"实用","slug":"实用","permalink":"https://leekiwi.github.io/categories/实用/"}],"tags":[{"name":"插件 开发","slug":"插件-开发","permalink":"https://leekiwi.github.io/tags/插件-开发/"}]},{"title":"nodejs学习笔记","slug":"node-js-study-note","date":"2018-08-28T12:42:30.000Z","updated":"2018-09-10T10:16:47.677Z","comments":true,"path":"2018/08/28/node-js-study-note/","link":"","permalink":"https://leekiwi.github.io/2018/08/28/node-js-study-note/","excerpt":"Nodejs 学习笔记node 内部对模块输出 module.exports 的实现 变量 module 是 Node 在加载 js 文件前准备的一个变量，并将其传入加载函数","text":"Nodejs 学习笔记node 内部对模块输出 module.exports 的实现 变量 module 是 Node 在加载 js 文件前准备的一个变量，并将其传入加载函数 12345678910111213141516171819202122// 准备module对象var module = &#123; id: &apos;hello&apos;, exports: &#123;&#125;&#125;;var load = function(module) &#123; // 读取的hello.js代码 function greet(name) &#123; console.log(&apos;Hello, &apos; + name + &apos;!&apos;); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;;var exported = load(module);// 保存modulesave(module, exported); 默认情况下，Node 准备的 exports 变量和 module.exports 变量实际上是同一个变量，所以一下两种写法都支持 123456789101112// method 1module.exports = &#123; foo: foo, bar: bar&#125;;ormodule.exports.foo = foo;module.exports.bar = bar;// method 2exports.foo = foo;exports.bar = bar; process 下一轮事件循环 回调 123process.nextTick(function() &#123; console.log(&apos;nextTick callback&apos;);&#125;); 程序即将退出 回调 12345process.on(&apos;exit&apos;, function(code) &#123; console.log(&apos;about to exit with code&apos; + code);&#125;);console.log(&apos;nextTick set&apos;); readFile/readFileSync writeFile/writeFileSync stat 异步读取一个文本文件 123456789fs.readFile(&apos;./hello.js&apos;, &apos;utf-8&apos;, function(err, data) &#123; console.log(&apos;read file start...&apos;); if(err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 异步读取一个二进制文件 12345678910111213fs.readFile(&apos;1.jpg&apos;, function(err, data) &#123; if(err) &#123; console.log(err); &#125; else &#123; // 返回一个buffer对象 console.log(data); // Buffer对象转化成字符串 console.log(data.toString(&apos;utf-8&apos;)); // 文件大小 console.log(data.length + &apos; bytes&apos;); &#125;&#125;); 同步读取一个文件直接返回，读取错误用 try…catch 捕获 123456789try &#123; var data = fs.readFileSync(&apos;./1.jpg&apos;); console.log(data);&#125;catch(err) &#123; console.log(err);&#125;console.log(&apos;readFileSync ended&apos;); 异步写入一个文件，默认是以 UTF-8 编码写入文本文件 12345678910var data = &apos;Hello,Node.js&apos;;// var data = fs.readFileSync(&apos;./1.jpg&apos;);fs.writeFile(&apos;output.txt&apos;, data, function(err) &#123; if(err) &#123; console.log(err); &#125; else &#123; console.log(&apos;write file finished&apos;); &#125;&#125;); 同步写入文本到一个文件 123var data = &apos;Hello,Node.js,I am sync data&apos;;fs.writeFileSync(&apos;output.txt&apos;, data);console.log(&apos;writeFileSync ended&apos;); 获取文件信息 1234567891011121314151617181920fs.stat(&apos;./1.jpg&apos;, function(err, stat) &#123; if(err) &#123; console.log(err); &#125; else &#123; // 是否是文件 console.log(&apos;isFile:&apos; + stat.isFile()); // 是否是目录 console.log(&apos;isDirectory:&apos; + stat.isDirectory()); if(stat.isFile()) &#123; // 文件大小 console.log(&apos;size:&apos; + stat.size); // 创建时间，Date对象 console.log(&apos;birth time:&apos; + stat.birthtime); // 修改时间，Date对象 console.log(&apos;modified time:&apos; + stat.mtime); &#125; &#125;&#125;); PS:绝大部分需要在服务器运行期反复执行业务逻辑，必须使用异步代码服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码 createReadStream createWriteStream pipe 在 node.js 中，流也是一个对象，我们只需要响应流的事件就可以了。data 事件表示流的数据已经可以读取了，end 事件表示这个流已经到末尾了，没有数据可以读取了，error 事件表示出错。 1234567891011121314var rs = fs.createReadStream(&apos;./data.txt&apos;, &apos;utf-8&apos;);// data事件可能有多次，每次传递的chunk是流的一部分数据rs.on(&apos;data&apos;, function(chunk) &#123; console.log(&apos;data event:&apos;, chunk);&#125;);rs.on(&apos;end&apos;, function (chunk) &#123; console.log(&apos;end event:&apos;);&#125;);rs.on(&apos;error&apos;, function (chunk) &#123; console.log(&apos;error event:&apos;);&#125;); 以流的形式写入文件，只需要不断调用 write()方法，最后以 end()结束 12345var ws = fs.createWriteStream(&apos;./data.txt&apos;);ws.write(&apos;user stream write data\\n&apos;);ws.write(&apos;loading...\\n&apos;);ws.write(&apos;END&apos;);ws.end(); pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里 1234var rs = fs.createReadStream(&apos;./data.txt&apos;);var ors = fs.createReadStream(&apos;./output.txt&apos;);var ws = fs.createWriteStream(&apos;./output.txt&apos;);rs.pipe(ws); 创建一个服务器 123456789101112131415var server = http.createServer(function(request, response) &#123; // http请求头的method和url console.log(&apos;header meathod:&apos;, request.method); console.log(&apos;header url:&apos;, request.url); // 将http响应200写入response，同时设置content-type response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将http响应的html内容写入response response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://localhost:8080&apos;); 实现一个文件服务器，拼接访问路径读取本地文件，从命令参数获取 root 目录，默认是当前目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var root = path.resolve(&apos;.&apos;);console.log(&apos;Static root dir:&apos; + root);// 创建服务器 var server = http.createServer(function (request, response) &#123; // node提供url模块解析url字符串 获取url的path var pathname = url.parse(request.url).pathname; if (pathname === &apos;/favicon.ico&apos;) &#123; return; &#125; console.log(&apos;url:&apos;, url.parse(request.url)); // 获取对应本地文件路径 var filepath = path.join(root, pathname); // 读取文件状态 fs.stat(filepath, function (err, stats) &#123; // 文件出错 if (err) &#123; console.log(&apos;file error!&apos;); response.end(&apos;&lt;h1&gt;file error!&lt;/h1&gt;&apos;); return; &#125; // 是文件 if (stats.isFile()) &#123; console.log(&apos;200 &apos; + request.url); response.writeHead(200); // 将文件流导入response fs.createReadStream(filepath).pipe(response); &#125; // 文件不存在 else &#123; console.log(&apos;404 &apos; + request.url); response.writeHead(404); // 将文件流导入response response.end(&apos;&lt;h1&gt;404 not found!&lt;/h1&gt;&apos;); &#125; &#125;);&#125;);server.listen(8080);console.info(&apos;Server is runing at http://localhost:8080/&apos;); express 是第一代流行的 web 框架，它对 Node.js 的 HTTP 进行封装，语法基于 ES5，要实现异步代码，只有一个方法：回调。 koa2 完全基于 ES7 开发，使用 Promise 配合 async 实现异步 1234567891011121314151617181920212223242526272829// 创建一个Koa对象const app = new Koa();// 对于任何请求，app将调用该异步函数处理请求// ctx是koa封装request和response变量// next是koa传入的将要处理下一个异步函数// 每个async函数称为middleware// app.use()顺序决定了middleware的顺序app.use(async(ctx, next) =&gt; &#123; fs.readFile(&apos;./data.txt&apos;, &apos;utf-8&apos;, function(err, data) &#123; console.log(data); &#125;); // 调用下一个middleware，如果没有调用，则下一个middleware不会执行 await next();&#125;);app.use(async(ctx, next) =&gt; &#123; ctx.response.type = &apos;text/html&apos;; ctx.response.body = &apos;&lt;h1&gt;Hello, koa!&lt;/h1&gt;&apos;; console.log(&apos;response end&apos;); // 调用下一个middleware await next();&#125;);app.listen(3000);console.log(&apos;app started at http://localhost:3000/&apos;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://leekiwi.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://leekiwi.github.io/tags/nodejs/"}]},{"title":"对MVC、MVP和MVVM的简单认识","slug":"对MVC、MVP和MVVM的简单认识","date":"2018-08-27T11:00:30.000Z","updated":"2018-09-10T09:44:26.497Z","comments":true,"path":"2018/08/27/对MVC、MVP和MVVM的简单认识/","link":"","permalink":"https://leekiwi.github.io/2018/08/27/对MVC、MVP和MVVM的简单认识/","excerpt":"MVVM 的前世与今生1. 先聊一下 MVCMVC：Model（模型） View（视图） Controller（控制器），主要是基于分层的目的，让彼此的职责分开。 View 通过 Controller 和 Model 联系，Controller 是 View 和 Model 的协调者，view 和 Model 不直接联系，基本联系都是单向的。","text":"MVVM 的前世与今生1. 先聊一下 MVCMVC：Model（模型） View（视图） Controller（控制器），主要是基于分层的目的，让彼此的职责分开。 View 通过 Controller 和 Model 联系，Controller 是 View 和 Model 的协调者，view 和 Model 不直接联系，基本联系都是单向的。 2. 顺带提下 MVPMVP：是从 MVC 模式演变而来的，都是通过 Controller/Presenter 负责逻辑的处理+Model 提供数据+View 负责显示。 在 MVP 中，Presenter 完全把 View 和 Model 进行分离，主要的程序逻辑在 Presenter 里实现。并且，Presenter 和 View 是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更 View 的时候可以保持 Presenter 不变。 3. 再聊聊 MVVNMVVM：Model + View + ViewModel，把 MVC 中的 Controller 和 MVP 中的 Presenter 改成 ViewModel view 的变化会自动更新到 ViewModel，ViewModel 的变化也会自动同步到 View 上显示。这种自动同步是因为 ViewModel 中的属性实现了 Observer，当属性变更时都能触发对应操作。 View 是 HTML 文本的 js 模板； ViewModel 是业务逻辑层（一切 js 可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在 viewmodel 里面负责监控俩边的数据）； Model 数据层，对数据的处理（与后台数据交互的增删改查） 提一下我熟悉的 MVVM 框架：vue.js，Vue.js 是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 4. 一句话总结下不同之处MVC 中联系是单向的，MVP 中 P 和 V 通过接口交互，MVVP 的联系是双向的","categories":[{"name":"其它","slug":"其它","permalink":"https://leekiwi.github.io/categories/其它/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://leekiwi.github.io/tags/设计模式/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2018-08-22T07:45:30.000Z","updated":"2018-09-10T09:45:55.305Z","comments":true,"path":"2018/08/22/正则表达式/","link":"","permalink":"https://leekiwi.github.io/2018/08/22/正则表达式/","excerpt":"正则规则汇总对字符串的处理，一般分为字符串操作和正则操作。 字符串操作 str.search(regStr) 返回 regStr 在 str 中第一个出现的位置 str.replace(regStr,newStr) 返回替换在 str 中 regStr 后字符串","text":"正则规则汇总对字符串的处理，一般分为字符串操作和正则操作。 字符串操作 str.search(regStr) 返回 regStr 在 str 中第一个出现的位置 str.replace(regStr,newStr) 返回替换在 str 中 regStr 后字符串 str.substring(n1,n2) 返回 str 从 n1 位置到 n2 位置前一个字符串 str.chartAt(n) 返回 n 位置字符 str.split(regStr) 返回以 regStr 隔开的数组 str.match(reg) 返回在 str 中符合正则 reg 的字符串数组 正则操作var reg=new RegExp(regStr,’i’); //创建正则对象 var reg=/regStr/i; //隐式创建正则对象 reg.test(str) str 是否包含 reg 返回 true/false reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引 基础用法 /a|b/ a 或 b /[abc]/ a 或 b 或 c /[a-zA-Z0-9]/ 所有数字和字母 /[^a-za-z0-9]/ 除了数字和字母 /.+/ 任意字符 /\\d/ 等价于/[0-9]/ 数字 /\\w/ 等价于/[a-z0-9_]/ 数字、字母和下划线 /\\s/ 等价于/“ “/ 空格 /\\D/ 等价于/[^0-9]/ 非数字 /\\W/ 等价于/[^a-z0-9_]/ 除了数字、字母和划线 /\\S/ 等价于/[^” “]/ 除了空格 /\\d{n,m}/ 数字最少出现 n 次，最多出现 m 次 /\\d{1,}/ 等价于/\\d+/ 数字最少出现 1 次 /\\d{0,}/ 等价于/\\d*/ 数字最少出现 0 次 /\\d{0,1}/ 等价于/\\d?/ 数字最多出现 1 次 /^\\d$/ 以数字开头且以数字结尾 /[\\u4e00-\\u9fa5]/ 汉字匹配范围 \\b 单词边界 \\B 非单词边界 ?=n 匹配任何其后紧接指定字符串 n 的字符串 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 疑难点在个人接触正则过程中遇到的一些不易理解的地方 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 表达式 描述 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\\ ) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\\ ies) 就是一个比 ‘industry\\ industries’ 更简略的表达式。 (?=pattern 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95\\ 98\\ NT\\ 2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\\ 98\\ NT\\ 2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 一直对正则中的 match 和 exec 不易分清，下面来做一下比较。 1. matchmatch 方法属于 String 正则表达方法 语法: 1str.match(regexp) str：要进行匹配的字符串 regexp：一个正则表达式(或者由 RegExp()构造成的正则表达式) match 的用法主要区分就是正则表达式是否有全局标示 g 如果有 g 全局标志，那么返回的数组保存的是，所有匹配的内容。 如果没有 g 全局标志，那么返回的数组 arr.arr[0]保存的是完整的匹配.arr[1]保存的是第一个括号里捕获的字串，依此类推 arr[n]保存的是第 n 个括号捕获的内容。 2. exec与 match 方法不同 exec 属于正则表达式的方法 语法： 1var result1 = regexp.exec(str); regexp：正则表达式 str：要匹配的字串 exec 与 match 的关联就是 exec（g 有没有都无影响）就等价于不含有 g 全局标志的 match，即返回数组 arr[0]为匹配的完整串，其余的为括号里捕获的字符串。 但如果有 g 对 exec 本身的影响是，当一个具有 g 的正则表达式调用 exec()时，他将该对象的 lastIndex 设置到紧接这匹配子串的字符位置。当第二次调用 exec 时将从lastIndex 所指示的字符位置开始检索，利用这个特点可以反复调用 exec 遍历所有匹配，等价于 match 具有 g 标志。 1234var arrmatch = str.match(reg);for(var i =0; i &lt; arrmatch.length; i++)&#123; document.write(arrmatch[i] +&quot;----&gt;&quot;);&#125; 可见上面的 exec 和 match 是等价的. reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引如： 1234567891011121314var str = &quot;abc123bef345olj89,ed&quot;;var reg = /\\d+/g;console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex); 总结 主要区分 match 具有 g 和没有 g 的区别，没有 g 的时候与 exec 是等价的。 而 exec 返回的串类型不受 g 影响，但具有 g 时候会驱动 lastIndex 可以模拟遍历所有匹配，可以与 match 具有 g 的时候等价。 顺便加强理解 ip 正则表达式格式由”.”分割成四段，每一段范围是 0-255，拿出其中一段进行分析 范围 表达式 0-9 \\d 10-99 [1-9]\\d 100-199 1\\d{2} 200-249 2[0-4]\\d 250-255 25[0-5] 所以，其中一段构成的正则表达式是 1\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5] ，整个 ip 正则为 1/^(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])$/ 同理端口号范围是 0-65535 范围 表达式 0-9 \\d 10-99 [1-9]\\d 100-999 [1-9]\\d{2} 1000-9999 [1-9]\\d{3} 10000-59999 [1-5]\\d{4} 60000-64999 6[0-4]\\d{3} 65000-65499 65[0-4]\\d{2} 65500-65529 655[0-2]\\d 65530-65535 65553[0-5] 所以，整个端口号正则为 1/\\d|[1-9]\\d&#123;1,3&#125;|[1-5]d&#123;4&#125;|6[0-4]\\d&#123;3&#125;|65[0-4]\\d&#123;2&#125;|655[0-2]\\d|65553[0-5]/","categories":[{"name":"javascript","slug":"javascript","permalink":"https://leekiwi.github.io/categories/javascript/"}],"tags":[{"name":"javascript 正则","slug":"javascript-正则","permalink":"https://leekiwi.github.io/tags/javascript-正则/"}]},{"title":"理解同步、异步和事件循环","slug":"理解同步、异步和事件循环","date":"2018-08-20T12:42:30.000Z","updated":"2018-09-10T09:46:25.551Z","comments":true,"path":"2018/08/20/理解同步、异步和事件循环/","link":"","permalink":"https://leekiwi.github.io/2018/08/20/理解同步、异步和事件循环/","excerpt":"JavaScript 运行机制 所有同步任务都在主线程上执行，形成一个执行栈；","text":"JavaScript 运行机制 所有同步任务都在主线程上执行，形成一个执行栈； 主线程发起异步请求，相应的工作线程就会去执行异步任务，主线程可以继续执行后面的代码； 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件，也就是一个消息； 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行； 主线程把当前的事件执行完成之后，再去读取任务队列，如此反复重复执行，这样就行程了事件循环。 1、单线程JS 引擎在解释和执行 JavaScript 代码线程只有一个，叫做主线程。但实际还存在其他线程，如：处理 Ajax 请求线程，处理 DOM 事件线程，定时器线程，和文件读写线程等，叫做工作线程。 2、同步和异步同步：如果函数返回的时候，调用者就能够得到预期结果。 1Math.sqrt(2); 异步：函数返回的时候，调用者还不能够得到预期结果，而是需要通过一定手段得到。 123fs.readFile(&quot;foo.txt&quot;, &quot;utf8&quot;, function(err, data)&#123; console.log(data)&#125;) 上面代码中，我们希望 fs.readFile 函数读取文件，并打印出来，但是在 fs.readFile 函数返回时，我们期望的结果并不会发生，而是要等文件全部读取完成之后。 异步 AJAX： 主线程：“你好，AJAX 线程。请你帮我发个 HTTP 请求吧，我把请求地址和参数都给你了。” AJAX 线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。” 主线程：：“谢谢，你拿到响应后告诉我一声啊。” (接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。) 同步 AJAX： 主线程：“你好，AJAX 线程。请你帮我发个 HTTP 请求吧，我把请求地址和参数都给你了。” AJAX 线程：“……” 主线程：：“喂，AJAX 线程，你怎么不说话？” AJAX 线程：“……” 主线程：：“喂！喂喂喂！” AJAX 线程：“……” (一炷香的时间后) 主线程：：“喂！求你说句话吧！” AJAX 线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。” 正因为 JavaScript 时单线程，同步容易造成阻塞，所以，对于耗时和操作事件不确定操作，使用异步就成了必然选择。 3、异步过程一个异步过程通常时这样的： 主线程发起一个异步请求，相应的工作线程接收线程请求并告知主线程已收到；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定动作（调用回调函数）。 异步函数通常具有一下形式： 1A(arg..., callbackFn) 他可以叫做异步过程的发起函数，或者叫做异步任务注册函数。 从主线程的角度看，一个一度过程包括两个要素： 发起函数（注册函数） 回到函数 4、消息队列和事件循环异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制时怎样实现的呢？答案是利用消息队列和事件循环。 一句话概括： 工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。 消息队列：消息队列是一个先进先出的队列，放着各种消息。 事件循环：事件循环是指主线程从消息队列中取消息，执行的过程。 实际上，主线程只会做一件事，就是从消息队列里面取消息、执行消息，再去消息，再执行。当消息队列为空时，就会等待知道消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 消息队列中放的消息是什么东西？消息的具体结构当然跟具体的实现有关，可以认为： 消息就是注册异步任务时添加的回调函数。 以异步 Ajax 为例 123$.ajax(&apos;http://segmentfault.com&apos;, function(resp) &#123; console.log(&apos;我是响应：&apos;, resp);&#125;); 主线程发起 Ajax 请求后，会继续执行其他代码。Ajax 线程负责请求 segmentfault.com，拿到响应后，它会把响应封装成一个 JavaScript 对象，然后构成一条消息： 123var message = function() &#123; callbackFn();&#125; 其中 callbackFn 就是前面代码中成功响应时的回调函数。 主线程在执行完当前循环中所有代码后，就会到消息队列取出这条消息（也就是 message 函数），并执行它，到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，Ajax 线程在收到 HTTP 响应后，也就没有必要通知主线程，从而没必要往消息队列放消息。 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 5、异步与事件 消息队列中的每条消息实际上都对应着一个事件 有一类很重要的异步过程：DOM 事件 1234var button = document.getElement(&apos;#btn&apos;);button.addEventListener(&apos;click&apos;, function(e) &#123; console.log();&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。 另一方面，所有的异步过程也都可以用事件来描述。例如：setTimeout 可以看成对应一个时间到了！的事件。前文的 setTimeout(fn, 1000);可以看成： 1timer.addEventListener(&apos;timeout&apos;, 1000, fn); 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。 6、macrotasks 与 microtasks 的区别 macrotasks: setTimeout setInterval setImmediate I/O UI 渲染 microtasks: Promise process.nextTick Object.observe MutationObserver microtask 会在当前循环中执行完成,而 macrotask 会在下一个循环中执行","categories":[{"name":"js高级","slug":"js高级","permalink":"https://leekiwi.github.io/categories/js高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://leekiwi.github.io/tags/javascript/"}]},{"title":"Git简记","slug":"Git简记","date":"2018-07-27T13:04:26.000Z","updated":"2018-09-10T10:16:11.523Z","comments":true,"path":"2018/07/27/Git简记/","link":"","permalink":"https://leekiwi.github.io/2018/07/27/Git简记/","excerpt":"Git 食用手册0. 前言最近有个项目比较赶，于是决定 8 个人一个并行完成，单独把项目拿出来用 gitea 管理，没人分一个模块开发，对应也给分支，效果不过，从中也帮助自己重新温习了一下 git 的使用，小记一下。","text":"Git 食用手册0. 前言最近有个项目比较赶，于是决定 8 个人一个并行完成，单独把项目拿出来用 gitea 管理，没人分一个模块开发，对应也给分支，效果不过，从中也帮助自己重新温习了一下 git 的使用，小记一下。 1. 安装和使用 在 MAC 上，安装 homebrew，然后通过homebrew 安装 Git。 在 MAC 上另一种安装方法，从 AppStore 安装 Xcode，Xcode 集成了 Git，不过默认没有安装，你需要运行 Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 在 Windows 上，下载安装包，默认下一步，安装完成即可。 安装完后自报家门 12$ git config --global user.name &quot;wuwhs&quot;$ git config --global user.email &quot;email@example.com&quot; 创建版本库初始化一个 Git 仓库，使用git init命令。添加文件到 Git 仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 2. 时光穿梭 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 HEAD 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本，git log --pretty=oneline --abbrev-commit在一行显示缩写提交号。 场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景 1，第二步按场景 1 操作。 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 3. 远程仓库 创建 SSH Key。$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;。 登陆 GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容。 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git。 关联后，使用命令git push -u origin master第一次推送 master 分支的所有内容。 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 4. 分支管理 Git 鼓励大量使用分支。 查看分支：git branch。 创建分支：git branch &lt;name&gt;。 切换分支：git checkout &lt;name&gt;。 创建+切换到当前分支：git checkout -b &lt;name&gt;。 合并某分支到当前分支：git merge &lt;name&gt;。 删除分支：git branch -d &lt;name&gt;。 当 Git 无法自动合并分支时，就必须首先剞劂冲突，解决冲突后，再提交，合并完成用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fash-forward合并就看不出来曾经做过合并。 当手头工作没有完成时，先把工作现场git stash一下，然后去修复 bug，修复后，再git stash list查看历史 stash，一是用git stash apply恢复，但恢复后，stash 内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把 stash 内容也删了。 查看远程库信息，使用git remote -v。 从本地推送分支，使用git push origin branch-name，如果失败，先用git pull抓取远程的新提交。 再本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致。 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 5. 标签 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD,也可以指定一个 commit id。 git tag -a &lt;tagname&gt; -m &quot;balabala...&quot;可以指定标签信息。 git tag -s &lt;tagname&gt; -m &quot;balabala...&quot;可以用 PGP 签名标签。 命令git tag可以查看所有标签。 命令git push origin &lt;tagname&gt;可以推送一个本地标签。 命令git push origin --tags可以推送全部未推送过的本地标签。 命令git tag -d &lt;tagname&gt;可以删除一个本地标签。 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 6. 举个应用栗子 最初在远程创建项目仓库有master和develp分支，参与开发人员先在自己一个文件夹下，调出git Bash，然后输入命令git init，再把仓库git clone下来 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www$ git initInitialized empty Git repository in D:/appSoft/wampserver/wamp64/www/.git/MINGW32 /d/appSoft/wampserver/wamp64/www (master)$ git clone git@github.com:wuwhs/demo.gitCloning into &apos;demo&apos;...Warning: Permanently added the RSA host key for IP address &apos;13.229.188.59&apos; to the list of known hosts.warning: You appear to have cloned an empty repository.Checking connectivity... done. cd demo进入clone下载的目录里，用git branch develop在本地创建一个对应的develop分支 1234567891011121314MINGW32 /d/appSoft/wampserver/wamp64/www (master)$ cd demoMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch* masterMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch developMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch develop* master 再次用git branch查看已经新建了一个develop分支 git checkout develop切换到当前develop分支 123MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git checkout developSwitched to branch &apos;develop&apos; 用git pull origin develop:develop，即：git pull origin &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;，当本地和远程分支名相同时，可以简写成一个，也就是git pull origin develop，拉取远程develop分支完成，然后开发人员就可以在这个分支上工作了 123456789101112MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pull origin develop:developremote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo 7ff2cb0..7ab2842 develop -&gt; develop 7ff2cb0..7ab2842 develop -&gt; origin/developwarning: fetch updated the current branch head.fast-forwarding your working tree fromcommit 7ff2cb0627be357fa15db4e38e1bfe8fc820b8ec.Already up-to-date. 当一天了工作完成，要提交到远程分支，首先要拉取一下别人提交的代码，防止版本冲突 123456789101112MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo f848dc7..d696375 develop -&gt; origin/developUpdating f848dc7..d696375Fast-forward demo.txt | 2 ++ 1 file changed, 2 insertions(+) PS：直接偷懒pull可能会出现没有找到tracking的分支 1234567891011MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:git branch --set-upstream-to=origin/&lt;branch&gt; develop 这时候要手动添加一下对应分支依赖git branch --set-upstream-to=origin/&lt;branch&gt; develop 12345678910111213141516 MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git branch --set-upstream-to=origin/develop developBranch develop set up to track remote branch develop from origin.MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo f848dc7..d696375 develop -&gt; origin/developUpdating f848dc7..d696375Fast-forward demo.txt | 2 ++ 1 file changed, 2 insertions(+) 将本地分支提交到对应远程分支上，git push origin develop:develop，即：git push origin &lt;远程主机&gt;&lt;本地分支名&gt;:&lt;远程分支名&gt;，如果名称一样可以简写，也就是git push origin develop 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git push origin develop:developCounting objects: 9, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (9/9), 759 bytes | 0 bytes/s, done.Total 9 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To git@github.com:wuwhs/demo.git d696375..3c00c0c develop -&gt; develop 项目测试 OK 了，本地分支合并到master分支上，要用到git merge &lt;branch&gt; 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git checkout masterSwitched to branch &apos;master&apos;MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git merge developUpdating c4d0377..3c00c0cFast-forward demo.txt | 9 +++++++++ 1 file changed, 9 insertions(+) 常用的操作就以上七步了，当然会有不同情形的应用。 7. 附录：git-cheat-sheet一般而言，常用的就是以上那些命令，有人专门的整理了一份比较全一点的文档 git-cheat-sheet，方便查阅。 配置列出当前配置： 1$ git config --list 列出 repository 配置： 1$ git config --local --list 列出全局配置： 1$ git config --global --list 列出系统配置： 1$ git config --system --list 设置用户名： 1$ git config --global user.name &quot;[firstname lastname]&quot; 设置用户邮箱： 1$ git config --global user.email &quot;[valid-email]&quot; 设置 git 命令输出为彩色： 1$ git config --global color.ui auto 设置 git 使用的文本编辑器设： 1$ git config --global core.editor vi 配置文件Repository 配置对应的配置文件路径[–local]： 1&lt;repo&gt;/.git/config 用户全局配置对应的配置文件路径[–global]： 1~/.gitconfig 系统配置对应的配置文件路径[–local]： 1/etc/gitconfig 创建复制一个已创建的仓库: 12# 通过 SSH$ git clone ssh://user@domain.com/repo.git 12#通过 HTTP$ git clone http://domain.com/user/repo.git 创建一个新的本地仓库: 1$ git init 本地修改显示工作路径下已修改的文件： 1$ git status 显示与上次提交版本文件的不同： 1$ git diff 把当前所有修改添加到下次提交中： 1$ git add . 把对某个文件的修改添加到下次提交中： 1$ git add -p &lt;file&gt; 提交本地的所有修改： 1$ git commit -a 提交之前已标记的变化： 1$ git commit 附加消息提交： 1$ git commit -m &apos;message here&apos; 提交，并将提交时间设置为之前的某个日期: 1git commit --date=&quot;`date --date=&apos;n day ago&apos;`&quot; -am &quot;Commit Message&quot; 修改上次提交（请勿修改已发布的提交记录!） 1$ git commit --amend 修改上次提交的 committer date： 1GIT_COMMITTER_DATE=&quot;date&quot; git commit --amend 修改上次提交的 author date： 1git commit --amend --date=&quot;date&quot; 把当前分支中未提交的修改移动到其他分支： 123git stashgit checkout branch2git stash pop 将 stashed changes 应用到当前分支： 1git stash apply 删除最新一次的 stashed changes： 1git stash drop 搜索从当前目录的所有文件中查找文本内容： 1$ git grep &quot;Hello&quot; 在某一版本中搜索文本： 1$ git grep &quot;Hello&quot; v2.5 提交历史从最新提交开始，显示所有的提交记录（显示 hash， 作者信息，提交的标题和时间）： 1$ git log 显示所有提交（仅显示提交的 hash 和 message）： 1$ git log --oneline 显示某个用户的所有提交： 1$ git log --author=&quot;username&quot; 显示某个文件的所有修改： 1$ git log -p &lt;file&gt; 仅显示远端分支与远端分支提交记录的差集： 1$ git log --oneline &lt;origin/master&gt;..&lt;remote/master&gt; --left-right 谁，在什么时间，修改了文件的什么内容： 1$ git blame &lt;file&gt; 显示 reflog： 1$ git reflog show 删除 reflog： 1$ git reflog delete 分支与标签列出所有的分支： 1$ git branch 列出所有的远端分支： 1$ git branch -r 切换分支： 1$ git checkout &lt;branch&gt; 创建并切换到新分支: 1$ git checkout -b &lt;branch&gt; 基于当前分支创建新分支： 1$ git branch &lt;new-branch&gt; 基于远程分支创建新的可追溯的分支： 1$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt; 删除本地分支: 1$ git branch -d &lt;branch&gt; 强制删除一个本地分支：将会丢失未合并的修改！ 1$ git branch -D &lt;branch&gt; 给当前版本打标签： 1$ git tag &lt;tag-name&gt; 给当前版本打标签并附加消息： 1$ git tag -a &lt;tag-name&gt; 更新与发布列出当前配置的远程端： 1$ git remote -v 显示远程端的信息： 1$ git remote show &lt;remote&gt; 添加新的远程端： 1$ git remote add &lt;remote&gt; &lt;url&gt; 下载远程端版本，但不合并到 HEAD 中： 1$ git fetch &lt;remote&gt; 下载远程端版本，并自动与 HEAD 版本合并： 1$ git remote pull &lt;remote&gt; &lt;url&gt; 将远程端版本合并到本地版本中： 1$ git pull origin master 以 rebase 方式将远端分支与本地合并： 1git pull --rebase &lt;remote&gt; &lt;branch&gt; 将本地版本发布到远程端： 1$ git push remote &lt;remote&gt; &lt;branch&gt; 删除远程端分支： 123$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)# orgit push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0) 发布标签: 1$ git push --tags 合并与重置(Rebase)将分支合并到当前 HEAD 中： 1$ git merge &lt;branch&gt; 将当前 HEAD 版本重置到分支中:请勿重置已发布的提交! 1$ git rebase &lt;branch&gt; 退出重置: 1$ git rebase --abort 解决冲突后继续重置： 1$ git rebase --continue 使用配置好的 merge tool 解决冲突： 1$ git mergetool 在编辑器中手动解决冲突后，标记文件为已解决冲突： 12$ git add &lt;resolved-file&gt;$ git rm &lt;resolved-file&gt; 合并提交： 1$ git rebase -i &lt;commit-just-before-first&gt; 把上面的内容替换为下面的内容： 原内容： 123pick &lt;commit_id&gt;pick &lt;commit_id2&gt;pick &lt;commit_id3&gt; 替换为： 123pick &lt;commit_id&gt;squash &lt;commit_id2&gt;squash &lt;commit_id3&gt; 撤销放弃工作目录下的所有修改： 1$ git reset --hard HEAD 移除缓存区的所有文件（i.e. 撤销上次 git add）: 1$ git reset HEAD 放弃某个文件的所有本地修改： 1$ git checkout HEAD &lt;file&gt; 重置一个提交（通过创建一个截然不同的新提交） 1$ git revert &lt;commit&gt; 将 HEAD 重置到指定的版本，并抛弃该版本之后的所有修改： 1$ git reset --hard &lt;commit&gt; 用远端分支强制覆盖本地分支： 1git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature 将 HEAD 重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改： 1$ git reset &lt;commit&gt; 将 HEAD 重置到上一次提交的版本，并保留未提交的本地修改： 1$ git reset --keep &lt;commit&gt; 删除添加.gitignore 文件前错误提交的文件： 123$ git rm -r --cached .$ git add .$ git commit -m &quot;remove xyz file&quot; 完~ 可参考文章： git-guide 廖雪峰 git 教程 git-scm Git Cheat Sheet 中文版","categories":[{"name":"git","slug":"git","permalink":"https://leekiwi.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://leekiwi.github.io/tags/git/"}]},{"title":"搞定css三列布局","slug":"搞定css三列布局","date":"2018-07-22T11:32:30.000Z","updated":"2018-09-10T09:47:13.194Z","comments":true,"path":"2018/07/22/搞定css三列布局/","link":"","permalink":"https://leekiwi.github.io/2018/07/22/搞定css三列布局/","excerpt":"三列布局 谈到布局，首先就要想到定位，当别人问我，css 的 position 定位有哪些取值，分别表示什么意思？呃….. 定位position 有六个属性值：static、relative、absolute、fixed、sticky 和 inherit。","text":"三列布局 谈到布局，首先就要想到定位，当别人问我，css 的 position 定位有哪些取值，分别表示什么意思？呃….. 定位position 有六个属性值：static、relative、absolute、fixed、sticky 和 inherit。 static（默认）：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于父级元素中。 relative：元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。 absolute：元素框不再占有文档位置，并且相对于包含块进行偏移（所谓包含块就是最近一级外层元素 position 不为 static 的元素）。 fixed：元素框不再占有文档流位置，并且相对于视窗进行定位。 sticky：css3 新增属性值，粘性定位，相当于 relative 和 fixed 的混合。最初会被当作是 relative，相对原来位置进行偏移；一旦超过一定的阈值，会被当成 fixed 定位，相对于视口定位。 三列布局三列布局，其中一列宽度自适应，在 PC 端最常用之一，搞定了三列布局，其他一样的套路。 方式一：浮动布局缺点：html 结构不正确,当包含区域宽度小于左右框之和，右边框会被挤下来 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .tree-columns-layout.float .left &#123; float: left; width: 300px; background-color: #a00; &#125; .tree-columns-layout.float .right &#123; float: right; width: 300px; background-color: #0aa; &#125; .tree-columns-layout.float .center &#123; /* left: 300px; right: 300px; */ margin: 0 300px; background-color: #aa0; overflow: auto; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout float&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是浮动布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是浮动布局右框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是浮动布局中间框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式二：定位布局缺点：要求父级要有非 static 定位，如果没有，左右框容易偏移出去 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; .tree-columns-layout.position &#123; position: relative; &#125; .tree-columns-layout.position .left &#123; position: absolute; left: 0; top: 0; width: 300px; background-color: #a00; &#125; .tree-columns-layout.position .right &#123; position: absolute; right: 0; top: 0; width: 300px; background-color: #0aa; &#125; .tree-columns-layout.position .center &#123; margin: 0 300px; background-color: #aa0; overflow: auto; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout position&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是浮动定位左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是浮动定位中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是浮动定位右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式三：表格布局缺点：没什么缺点，恐惧 table 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; .tree-columns-layout.table &#123; display: table; width: 100%; &#125; .tree-columns-layout.table &gt; article &#123; display: table-cell; &#125; .tree-columns-layout.table .left &#123; width: 300px; background-color: #a00; &#125; .tree-columns-layout.table .center &#123; background-color: #aa0; &#125; .tree-columns-layout.table .right &#123; width: 300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout table&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是表格布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是表格布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是表格布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式四：flex 弹性布局缺点：兼容性 123456789101112131415161718192021222324252627282930313233&lt;style&gt; .tree-columns-layout.flex &#123; display: flex; &#125; .tree-columns-layout.flex .left &#123; width: 300px; flex-shrink: 0; /* 不缩小 */ background-color: #a00; &#125; .tree-columns-layout.flex .center &#123; flex-grow: 1; /* 增大 */ background-color: #aa0; &#125; .tree-columns-layout.flex .right &#123; flex-shrink: 0; /* 不缩小 */ width: 300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout flex&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是flex弹性布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是flex弹性布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是flex弹性布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式五：grid 栅格布局缺点：兼容性 Firefox 52, Safari 10.1, Chrome 57, Opera 44 1234567891011121314151617181920212223242526272829&lt;style&gt; .tree-columns-layout.grid &#123; display: grid; grid-template-columns: 300px 1fr 300px; &#125; .tree-columns-layout.grid .left &#123; background-color: #a00; &#125; .tree-columns-layout.grid .center &#123; background-color: #aa0; &#125; .tree-columns-layout.grid .right &#123; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout grid&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是grid栅格布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是grid栅格布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是grid栅格布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式六：圣杯布局缺点：需要多加一层标签，html 顺序不对，占用了布局框的 margin 属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .tree-columns-layout.cup:after &#123; clear: both; content: &quot;&quot;; display: table; &#125; .tree-columns-layout.cup .center &#123; width: 100%; float: left; &#125; .tree-columns-layout.cup .center &gt; div &#123; margin: 0 300px; overflow: auto; background-color: #aa0; &#125; .tree-columns-layout.cup .left &#123; width: 300px; float: left; margin-left: -100%; background-color: #a00; &#125; .tree-columns-layout.cup .right &#123; width: 300px; float: left; margin-left: -300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout cup&quot;&gt; &lt;article class=&quot;center&quot;&gt; &lt;div&gt; &lt;h1&gt;我是圣杯布局中间框&lt;/h1&gt; &lt;/div&gt; &lt;/article&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是圣杯布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是圣杯布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt;","categories":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/tags/css/"},{"name":"布局","slug":"布局","permalink":"https://leekiwi.github.io/tags/布局/"}]},{"title":"水平且垂直居中方法（9种）","slug":"水平且垂直居中方法（9种）","date":"2018-06-01T12:40:30.000Z","updated":"2018-09-10T12:54:35.813Z","comments":true,"path":"2018/06/01/水平且垂直居中方法（9种）/","link":"","permalink":"https://leekiwi.github.io/2018/06/01/水平且垂直居中方法（9种）/","excerpt":"水平且垂直居中方法有哪些？这在实际工作中经常用到，小记一下。 演示 HTML 结构","text":"水平且垂直居中方法有哪些？这在实际工作中经常用到，小记一下。 演示 HTML 结构 1234567&lt;div id=\"div1\" class=\"div\"&gt; &lt;div id=\"div2\"&gt; &lt;div id=\"div3\"&gt; &lt;span&gt;i&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 一般的，水平居中相对垂直居中简单很多，对于内联元素，父级元素设置text-align: center;；对于块级元素，子级元素设置margin: 0 auto;。以下结合水平居中强调实现垂直居中。 1、已知父级元素宽高，父级元素定位非 static，子级元素定位设为position: absolute/fixed，再利用margin、left和top属性居中。1234567891011121314151617#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; background-color: #ff00ff;&#125; 注：需要已知父级元素固定宽高，才能确定margin-left和margin-right。 2、子级元素是内联元素，父级元素设置line-height属性垂直居中。1234567891011121314151617#div1 &#123; width: 200px; height: 200px; line-height: 120px; text-align: center; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; line-height: normal; text-align: left; display: inline-block; background-color: #ff00ff;&#125; 注：需要已知父级元素的固定高度，才可以确定line-height。 3、子级元素是内联元素，父级元素用display: table-cell;和vertical-align: middle;属性实现垂直居中。123456789101112131415#div1 &#123; width: 200px; height: 200px; display: table-cell; text-align: center; vertical-align: middle; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; display: inline-block; background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，inline-block、table-cell不兼容 ie67 4、对于子级是块级元素，父级元素同样用display: table-cell;和vertical-align: middle;属性实现垂直居中，水平方向居中用margin: 0 auto;。1234567891011121314#div1 &#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; margin: 0 auto; background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，table-cell不兼容 ie67 5、利用 css3 translate特性：位移是基于元素宽高的。12345678910111213141516171819#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%); -moz-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，translate属性兼容 IE9+ 6、当父级是浮动的，用display: table-cell;会失效，这时需要包三层，第一层display: table;，第二层display: table-cell; 第三次居中层12345678910111213141516171819202122232425#div1 &#123; width: 200px; height: 200px; position: relative; display: table; background-color: #ffff00; float: left;&#125;#div2 &#123; width: 100%; height: 100%; display: table-cell; vertical-align: middle; /* text-align: center; */ background-color: #cccccc;&#125;#div3 &#123; width: 100px; height: 100px; margin: 0 auto; /* display: inline-block; */ background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，但 HTML 标签层数较多。 7、绝对定位加四边定位为 0。123456789101112131415161718#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; top: 0; left: 0; right: 0; bottom: 0; margin: auto; position: absolute; background-color: #cccccc;&#125; 注：无需要确定父级元素的宽高，但把定位属性全用上了 8、利用 flex 布局justify-content: center;和align-items: center;属性居中。123456789101112131415#div1 &#123; width: 200px; height: 200px; display: flex; flex-direction: row; justify-content: center; align-items: center; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; background-color: #cccccc;&#125; 注：无需要确定父级元素的宽高，兼容 IE10+ 9、利用 grid 布局，划分成 3x3 栅格，第二行第二列格子垂直水平居中12345678910111213141516#div1 &#123; width: 200px; height: 200px; display: grid; background-color: #ffff00; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);&#125;#div2 &#123; width: 100px; height: 100px; background-color: #cccccc; grid-row-start: 2; grid-column-start: 2;&#125; 注：无需要确定父级元素的宽高，兼容性 Firefox 52, Safari 10.1, Chrome 57, Opera 44","categories":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/tags/css/"}]},{"title":"深入理解BFC","slug":"深入理解BFC","date":"2018-05-21T11:30:30.000Z","updated":"2018-09-10T12:54:43.670Z","comments":true,"path":"2018/05/21/深入理解BFC/","link":"","permalink":"https://leekiwi.github.io/2018/05/21/深入理解BFC/","excerpt":"1、相关定义1.1 Formatting contextFormatting context 是 W3C CSS2.1 规定中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block formatting context（简称 BFC）和 Inline formatting context（简称 IFC）。css2.1 中只有 BFC 和 IFC，css3 中还增加了 GFC 和 FFC。","text":"1、相关定义1.1 Formatting contextFormatting context 是 W3C CSS2.1 规定中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block formatting context（简称 BFC）和 Inline formatting context（简称 IFC）。css2.1 中只有 BFC 和 IFC，css3 中还增加了 GFC 和 FFC。 1.2 BFC 定义BFC(Block formatting context)直译为“块级格式化上下文”。它是独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。 1.3 BFC 布局规则： 内部的 Box 会在垂直方向，一个接一个地放置； Box 垂直方向地距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反）。即便存在浮动也是如此。 BFC 的区域不会与 float box 重叠。 BFC 就是页面的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素页参与计算。- 2、作用2.1 可生成 BFC 的元素 根元素 html； float 属性不为 none； position 为 absolute 或 fixed； display 为 inline-block， table-cell，table-caption，flex， inline-flex； overflow 不为 visible； 2.2 场景一：对于两栏或三栏浮动自适应布局，包含块边接触问题。12345678910111213141516171819202122232425&lt;style&gt; .left-center-right.float .left &#123; float: left; width: 200px; height: 100px; background-color: rgba(0, 0, 0, 0.7); &#125; .left-center-right.float .center &#123; background-color: rgb(13, 218, 233); height: 200px; &#125; .left-center-right.float .right &#123; float: right; width: 200px; height: 150px; background-color: rgb(189, 109, 109); &#125;&lt;/style&gt;&lt;section class=&quot;left-center-right float&quot;&gt; &lt;article class=&quot;left&quot;&gt;我是左边区域块&lt;/article&gt; &lt;article class=&quot;right&quot;&gt;我是右边区域块&lt;/article&gt; &lt;article class=&quot;center&quot;&gt;我是中间区域块&lt;/article&gt;&lt;/section&gt; 中间自适应栏边界会延展左右浮动区域 此时需要把中间栏变成 BFC 12345.left-center-right.float .center &#123; background-color: rgb(13, 218, 233); height: 200px; overflow: hidden;&#125; 2.3 场景二：子级元素有浮动，父级元素塌陷问题12345678910111213141516171819&lt;style&gt; .all-children-float .left &#123; float: left; width: 200px; height: 100px; background-color: rgba(0, 0, 0, 0.7); &#125; .all-children-float .right &#123; float: right; width: 200px; height: 150px; background-color: rgb(189, 109, 109); &#125;&lt;/style&gt;&lt;section class=&quot;all-children-float&quot;&gt; &lt;article class=&quot;left&quot;&gt;我是左边区域块&lt;/article&gt; &lt;article class=&quot;right&quot;&gt;我是右边区域块&lt;/article&gt;&lt;/section&gt; 此时需要将父级元素变成 BFC 123.all-children-float &#123; position: absolute;&#125; 2.3 场景三：垂直方向 margin 出现重合12345678910111213141516171819&lt;style&gt; .verticle-block .block1 &#123; width: 200px; height: 150px; background-color: rgb(13, 218, 233); margin: 20px; &#125; .verticle-block .block2 &#123; width: 150px; height: 150px; background-color: rgb(189, 109, 109); margin: 30px; &#125;&lt;/style&gt;&lt;section class=&quot;verticle-block&quot;&gt; &lt;article class=&quot;block1&quot;&gt;我是区域块1&lt;/article&gt; &lt;article class=&quot;block2&quot;&gt;我是区域块2&lt;/article&gt;&lt;/section&gt; Box 垂直方向的距离 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。 我们的做法是包一层标签，并转化成 BFC。 12345678910.wrapper1 &#123; overflow: hidden;&#125;&lt;section class=&quot;verticle-block&quot;&gt; &lt;div class=&quot;wrapper1&quot;&gt; &lt;article class=&quot;block1&quot;&gt;我是区域块1&lt;/article&gt; &lt;/div&gt; &lt;article class=&quot;block2&quot;&gt;我是区域块2&lt;/article&gt;&lt;/section&gt;","categories":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/categories/css/"}],"tags":[{"name":"css BFC","slug":"css-BFC","permalink":"https://leekiwi.github.io/tags/css-BFC/"}]},{"title":"css中的一些坑","slug":"css中的一些坑","date":"2018-05-06T10:36:30.000Z","updated":"2018-09-10T12:53:54.613Z","comments":true,"path":"2018/05/06/css中的一些坑/","link":"","permalink":"https://leekiwi.github.io/2018/05/06/css中的一些坑/","excerpt":"CSS 踩坑记1、如果子元素全部设置为浮动，则父元素是塌陷的 在元素末尾加块级空元素设置 clear:both；","text":"CSS 踩坑记1、如果子元素全部设置为浮动，则父元素是塌陷的 在元素末尾加块级空元素设置 clear:both； 1234.last &#123; display: block; clear: both;&#125; 在父级容器设置 before/after 模拟一个块级空元素 12345.clearfix:after &#123; content: ''; display: block; clear: both;&#125; 父级容器直接设置 overflow: auto/hidden; 2、普通文档流中块级垂直外边距合并解决办法：用 padding 代替，或改成 inline-block，或改成 float，或绝对定位 3、使用 transition 闪屏12345.demo &#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000;&#125; 过渡动画在没有启动硬件加速的情况下，会出现抖动现象，解决方案：用 translated3d、translateZ、transform 自动启动硬件加速，即改为： 1234.demo &#123; -webkit-transform: translated3d(0, 0, 0); transform: translated3d(0, 0, 0);&#125; ps:硬件加速导致 cpu 性能占用增加，电池电量消耗加大 4、超出内容用”…”表示123&lt;div class=\"line-clamp\"&gt;来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容&lt;/div&gt; 1234567.line-clamp &#123; width: 300px; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125; 说明： -webkit-line-clamp 用来限制在一个块元素显示的文本的行数 display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 缺点：只有移动端和 webkit 浏览器支持 还不够，最后末尾最好有点渐变到”…” 12345678910111213141516.line-clamp &#123; width: 300px; line-height: 20px; height: 40px; overflow: hidden; position: relative;&#125;.line-clamp:after &#123; content: '...'; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: linear-gradient(to right, transparent, #fff 55%);&#125; 说明： 将 height 设置为 line-height 整数倍，防止超出文字露出 ie10+才支持 linear-gradient 属性 缺点： 当文字少于区域大小时，也会出现省略号 输入框 placeholder 文字带颜色1234567891011121314151617input::-webkit-input-placeholder &#123; /* WebKit browsers */ font-size: 14px; color: #009a61;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ font-size: 14px; color: #009a61;&#125;input:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ font-size: 14px; color: #009a61;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/tags/css/"}]},{"title":"移动端适配-rem","slug":"移动端适配-rem","date":"2018-04-27T10:00:30.000Z","updated":"2018-09-10T12:54:57.822Z","comments":true,"path":"2018/04/27/移动端适配-rem/","link":"","permalink":"https://leekiwi.github.io/2018/04/27/移动端适配-rem/","excerpt":"通过封装 rem.js,动态获取屏幕宽度 通过 js 去动态计算根元素的 font-size，这样所有设备分辨率都能兼容适应","text":"通过封装 rem.js,动态获取屏幕宽度 通过 js 去动态计算根元素的 font-size，这样所有设备分辨率都能兼容适应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//designWidth:设计稿的实际宽度值，需要根据实际设置//maxWidth:制作稿的最大宽度值，需要根据实际设置//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750);(function(designWidth, maxWidth) &#123; var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement(&quot;style&quot;), tid; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width &gt; maxWidth &amp;&amp; (width = maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = &apos;html&#123;font-size:&apos; + rem + &apos;px;&#125;&apos;; &#125; if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(remStyle); &#125; else &#123; var wrap = doc.createElement(&quot;div&quot;); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; &#125; //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener(&quot;resize&quot;, function() &#123; clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener(&quot;pageshow&quot;, function(e) &#123; if (e.persisted) &#123; // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === &quot;complete&quot;) &#123; doc.body.style.fontSize = &quot;16px&quot;; &#125; else &#123; doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) &#123; doc.body.style.fontSize = &quot;16px&quot;; &#125;, false); &#125;&#125;)(640, 750); 当然也可以用 media query 设置适配集中主流的屏幕尺寸 12345678910111213141516171819202122232425262728html &#123; font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123; html &#123; font-size: 25px !important; &#125;&#125;@media only screen and (min-width: 428px)&#123; html &#123; font-size: 26.75px !important; &#125;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 30px !important; &#125;&#125;@media only screen and (min-width: 569px)&#123; html &#123; font-size: 35px !important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 40px !important; &#125;&#125; 提供一个移动端 base.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175body,dl,dd,ul,ol,h1,h2,h3,h4,h5,h6,pre,form,input,textarea,p,hr,thead,tbody,tfoot,th,td &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;html &#123; -ms-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none;&#125;body &#123; line-height: 1.5; font-size: 14px;&#125;body,button,input,select,textarea &#123; font-family: &apos;helvetica neue&apos;, tahoma, &apos;hiragino sans gb&apos;, stheiti, &apos;wenquanyi micro hei&apos;, \\5FAE\\8F6F\\96C5\\9ED1, \\5B8B\\4F53, sans-serif;&#125;b,strong &#123; font-weight: bold;&#125;i,em &#123; font-style: normal;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;table th,table td &#123; border: 1px solid #ddd; padding: 5px;&#125;table th &#123; font-weight: inherit; border-bottom-width: 2px; border-bottom-color: #ccc;&#125;img &#123; border: 0 none; width: auto\\9; max-width: 100%; vertical-align: top; height: auto;&#125;button,input,select,textarea &#123; font-family: inherit; font-size: 100%; margin: 0; vertical-align: baseline;&#125;button,html input[type=&quot;button&quot;],input[type=&quot;reset&quot;],input[type=&quot;submit&quot;] &#123; -webkit-appearance: button; cursor: pointer;&#125;button[disabled],input[disabled] &#123; cursor: default;&#125;input[type=&quot;checkbox&quot;],input[type=&quot;radio&quot;] &#123; box-sizing: border-box; padding: 0;&#125;input[type=&quot;search&quot;] &#123; -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box;&#125;input[type=&quot;search&quot;]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;input:focus &#123; outline: none;&#125;select[size],select[multiple],select[size][multiple] &#123; border: 1px solid #AAA; padding: 0;&#125;article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary &#123; display: block;&#125;audio,canvas,video,progress &#123; display: inline-block;&#125;body &#123; background: #fff;&#125;input::-webkit-input-speech-button &#123; display: none&#125;button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;","categories":[{"name":"mobile","slug":"mobile","permalink":"https://leekiwi.github.io/categories/mobile/"}],"tags":[{"name":"css","slug":"css","permalink":"https://leekiwi.github.io/tags/css/"}]},{"title":"vue的数据驱动原理及简单实现","slug":"vue的数据驱动原理及简单实现","date":"2017-09-10T01:00:30.000Z","updated":"2018-09-10T12:54:16.841Z","comments":true,"path":"2017/09/10/vue的数据驱动原理及简单实现/","link":"","permalink":"https://leekiwi.github.io/2017/09/10/vue的数据驱动原理及简单实现/","excerpt":"Vue双向数据绑定原理1、目标实现 理解双向数据绑定原理； 实现 &#123;&#123; &#125;&#125;、v-model和基本事件指令v-bind（:）、v-on（@）； 新增属性的双向绑定处理；","text":"Vue双向数据绑定原理1、目标实现 理解双向数据绑定原理； 实现 &#123;&#123; &#125;&#125;、v-model和基本事件指令v-bind（:）、v-on（@）； 新增属性的双向绑定处理； 2、双向数据绑定原理vue实现对数据的双向绑定，通过对数据劫持结合发布者-订阅者模式实现的。 2.1 Object.definePropertyvue通过Object.defineProperty来实现数据劫持，会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。 1234567891011121314Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; // do something return val; &#125;, set: function(newVal) &#123; // do something &#125;&#125;); 我们可以将一些方法放到里面，从而完成对数据的监听（劫持）和视图的同步更新。 2.2 过程说明实现双向数据绑定，首先要对数据进行数据监听，需要一个监听器Observer，监听所有属性。如果属性发生变化，会调用setter和getter，再去告诉订阅者Watcher是否需要更新。由于订阅者有很多个，我们需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理。还有，我们需要一个指令解析器Complie，对每个元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或绑定相应函数。当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 3、实现ObserverObserver是一个数据监听器，核心方法是我们提到过的Object.defineProperty。如果要监听所有属性的话，则需要通过递归遍历，对每个子属性都defineProperty。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 监听器构造函数 * @param &#123;Object&#125; data 被监听数据 */function Observer(data) &#123; if (!data || typeof data !== \"object\") &#123; return; &#125; this.data = data; this.walk(data);&#125;Observer.prototype = &#123; /** * 属性遍历 */ walk: function(data) &#123; var self = this; Object.keys(data).forEach(function(key) &#123; self.defineReactive(data, key, data[key]); &#125;); &#125;, /** * 监听函数 */ defineReactive: function(data, key, val) &#123; observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; console.log(\"属性：\" + key + \"被监听了，现在值为：\" + newVal); updateView(newVal); &#125; &#125;); updateView(val); &#125;&#125;/** * 监听器 * @param &#123;Object&#125; data 被监听对象 */function observe(data) &#123; return new Observer(data);&#125;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; // 监听数据 observe(this.data); return this;&#125;/** * 更新视图 * @param &#123;*&#125; val */function updateView(val) &#123; var $name = document.querySelector(\"#name\"); $name.innerHTML = val;&#125;var myvm = new MyVue(&#123; el: \"#demo\", data: &#123; name: \"hello word\" &#125;&#125;); 4、实现Dep在流程介绍中，我们需要创建一个可以订阅者的订阅器Dep，主要负责手机订阅者，属性变化的时候执行相应的订阅者，更新函数。下面稍加改造Observer，就可以插入我们的订阅器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Observer.prototype = &#123; // ... /** * 监听函数 */ defineReactive: function(data, key, val) &#123; var dep = new Dep(); observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; // 判断是否需要添加订阅者 什么时候添加订阅者呢？ 与实际页面DOM有关联的data属性才添加相应的订阅者 if (Dep.target) &#123; // 添加一个订阅者 dep.addSub(Dep.target); &#125; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; console.log(\"属性：\" + key + \"被监听了，现在值为：\" + newVal); // 通知所有订阅者 dep.notify(newVal); &#125; &#125;); updateView(val); // 订阅器标识本身实例 Dep.target = dep; // 强行执行getter，往订阅器中添加订阅者 var v = data[key]; // 释放自己 Dep.target = null; &#125;&#125;/** * 监听器 * @param &#123;Object&#125; data 被监听对象 */function observe(data) &#123; return new Observer(data);&#125;/** * 订阅器 */function Dep() &#123; this.subs = []; this.target = null;&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); console.log(\"this.subs:\", this.subs); &#125;, notify: function(data) &#123; this.subs.forEach(function(sub) &#123; sub.update(data); &#125;); &#125;, update: function(val) &#123; updateView(val) &#125;&#125;;// ... PS:将订阅器Dep添加到一个订阅者设计到getter里面，是为了让Watcher初始化进行触发。 5、实现Watcher订阅者Watcher在初始化的时候需要将自己添加到订阅器Dep中，那该如何添加呢？我们已经知道监听器Observer是在get函数执行添加了订阅者Watcher的操作，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作。那么，怎样去触发get函数？很简单，只需获取对应的属性值就可以触发了，因为我们已经用Object.defineProperty监听了所有属性。vue在这里做了个技巧处理，就是咋我们添加订阅者的时候，做一个判断，判断是否是事先缓存好的Dep.target，在订阅者添加成功后，把target重置null即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// .../** * 订阅者 * @param &#123;Object&#125; vm vue对象 * @param &#123;String&#125; exp 属性值 * @param &#123;Function&#125; cb 回调函数 */function Watcher(vm, exp, cb) &#123; this.vm = vm; this.exp = exp; this.cb = cb; // 将自己添加到订阅器 this.value = this.get();&#125;Watcher.prototype = &#123; update: function() &#123; this.run(); &#125;, run: function() &#123; var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); &#125; &#125;, get: function() &#123; // 缓存自己 做个标记 Dep.target = this; // 强制执行监听器里的get函数 // this.vm.data[this.exp] 调用getter，添加一个订阅者sub，存入到全局变量subs var value = this.vm.data[this.exp]; // 释放自己 Dep.target = null; return value; &#125;&#125;;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; observe(this.data); var $name = document.querySelector(\"#name\"); // 给name属性添加一个订阅者到订阅器中，当属性发生变化后，触发回调 var w = new Watcher(this, \"name\", function(val) &#123; $name.innerHTML = val; &#125;); return this;&#125; 到这里，其实已经实现了我们的双向数据绑定：能够根据初始数据初始化页面特定元素，同时当数据改变也能更新视图。 5、实现Compile步骤4整个过程都能有去解析DOM节点，而是直接固定节点进行替换。接下来我们就来实现一个解析器，完成一些解析和绑定工作。 获取页面的DOM节点，遍历存入到文档碎片对象中； 解析出文本节点，匹配&#123;&#123;&#125;&#125;（暂时只做”&#123;&#123;&#125;&#125;”的解析），用初始化数据替换，并添加相应订阅者； 分离出节点的指令v-on、v-bind和v-model，绑定相应的事件和函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262// .../** * 编译器构造函数 * @param &#123;String&#125; el 根元素 * @param &#123;Object&#125; vm vue对象 */function Compile(el, vm) &#123; this.vm = vm; this.el = document.querySelector(el); this.fragment = null; this.init();&#125;Compile.prototype = &#123; /** * 初始 */ init: function() &#123; if (this.el) &#123; console.log(\"this.el:\", this.el); // 移除页面元素生成文档碎片 this.fragment = this.nodeToFragment(this.el); // 编译文档碎片 this.compileElement(this.fragment); this.el.appendChild(this.fragment); &#125; else &#123; console.log(\"DOM Selector is not exist\"); &#125; &#125;, /** * 页面DOM节点转化成文档碎片 */ nodeToFragment: function(el) &#123; var fragment = document.createDocumentFragment(); var child = el.firstChild; // 此处添加打印，出来的不是页面中原始的DOM，而是编译后的？ // NodeList是引用关系，在编译后相应的值被替换了，这里打印出来的NodeList是后来被引用更新了的 console.log(\"el:\", el); // console.log(\"el.firstChild:\", el.firstChild.nodeValue); while (child) &#123; // append后，原el上的子节点被删除了，挂载在文档碎片上 fragment.appendChild(child); child = el.firstChild; &#125; return fragment; &#125;, /** * 编译文档碎片，遍历到当前是文本节点则去编译文本节点，如果当前是元素节点，并且存在子节点，则继续递归遍历 */ compileElement: function(fragment) &#123; var childNodes = fragment.childNodes; var self = this; [].slice.call(childNodes).forEach(function(node) &#123; // var reg = /\\&#123;\\&#123;\\s*(.+)\\s*\\&#125;\\&#125;/g; var reg = /\\&#123;\\&#123;\\s*((?:.|\\n)+?)\\s*\\&#125;\\&#125;/g; var text = node.textContent; if (self.isElementNode(node)) &#123; self.compileAttr(node); &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; reg.lastIndex = 0 /* var match; while(match = reg.exec(text)) &#123; self.compileText(node, match[1]); &#125; */ self.compileText(node, reg.exec(text)[1]); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node); &#125; &#125;); &#125;, /** * 编译属性 */ compileAttr: function(node) &#123; var nodeAttrs = node.attributes; var self = this; Array.prototype.forEach.call(nodeAttrs, function(attr) &#123; var attrName = attr.name; // 只对vue本身指令进行操作 if (self.isDirective(attrName)) &#123; var exp = attr.value; // v-on指令 if (self.isOnDirective(attrName)) &#123; self.compileOn(node, self.vm, exp, attrName); &#125; // v-bind指令 if(self.isBindDirective(attrName)) &#123; self.compileBind(node, self.vm, exp, attrName); &#125; // v-model else if (self.isModelDirective(attrName)) &#123; self.compileModel(node, self.vm, exp, attrName); &#125; node.removeAttribute(attrName); &#125; &#125;) &#125;, /** * 编译文档碎片节点文本，即对标记替换 */ compileText: function(node, exp) &#123; var self = this; var exps = exp.split(\".\"); var initText = this.vm.data[exp]; // 初始化视图 this.updateText(node, initText); // 添加一个订阅者到订阅器 var w = new Watcher(this.vm, exp, function(val) &#123; self.updateText(node, val); &#125;); &#125;, /** * 编译v-on指令 */ compileOn: function(node, vm, exp, attrName) &#123; // @xxx v-on:xxx var onRE = /^@|^v-on:/; var eventType = attrName.replace(onRE, \"\"); var cb = vm.methods[exp]; if (eventType &amp;&amp; cb) &#123; node.addEventListener(eventType, cb.bind(vm), false); &#125; &#125;, /** * 编译v-bind指令 */ compileBind: function (node, vm, exp, attrName) &#123; // :xxx v-bind:xxx var bindRE = /^:|^v-bind:/; var attr = attrName.replace(bindRE, \"\"); var val = vm.data[exp]; node.setAttribute(attr, val); &#125;, /** * 编译v-model指令 */ compileModel: function(node, vm, exp, attrName) &#123; var self = this; var val = this.vm.data[exp]; // 初始化视图 this.modelUpdater(node, val); // 添加一个订阅者到订阅器 new Watcher(this.vm, exp, function(value) &#123; self.modelUpdater(node, value); &#125;); // 绑定input事件 node.addEventListener(\"input\", function(e) &#123; var newVal = e.target.value; if (val === newVal) &#123; return; &#125; self.vm.data[exp] = newVal; // val = newVal; &#125;); &#125;, /** * 更新文档碎片相应的文本节点 */ updateText: function(node, val) &#123; node.textContent = typeof val === \"undefined\" ? \"\" : val; &#125;, /** * model更新节点 */ modelUpdater: function(node, val, oldVal) &#123; node.value = typeof val == \"undefined\" ? \"\" : val; &#125;, /** * 属性是否是vue指令，包括v-xxx:,:xxx,@xxx */ isDirective: function(attrName) &#123; var dirRE = /^v-|^@|^:/; return dirRE.test(attrName); &#125;, /** * 属性是否是v-on指令 */ isOnDirective: function(attrName) &#123; var onRE = /^v-on:|^@/; return onRE.test(attrName); &#125;, /** * 属性是否是v-bind指令 */ isBindDirective: function (attrName) &#123; var bindRE = /^v-bind:|^:/; return bindRE.test(attrName); &#125;, /** * 属性是否是v-model指令 */ isModelDirective: function(attrName) &#123; var mdRE = /^v-model/; return mdRE.test(attrName); &#125;, /** * 判断元素节点 */ isElementNode: function(node) &#123; return node.nodeType == 1; &#125;, /** * 判断文本节点 */ isTextNode: function(node) &#123; return node.nodeType == 3; &#125;&#125;;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; this.methods = options.methods; observe(this.data); new Compile(options.el, this.vm); return this;&#125; 这样我们就可以调用指令v-bind、v-on和v-model。 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style&gt; .red &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;h2 v-bind:class=\"myColor\"&gt;&amp;#123;&amp;#123; name &amp;#125;&amp;#125;&lt;/h2&gt; &lt;input type=\"text\" name=\"\" v-model=\"name\"&gt; &lt;button @click=\"clickOk\"&gt;Ok&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var myvm = new MyVue(&#123; el: \"#demo\", data: &#123; name: \"hello word\", myColor: \"red\" &#125;, methods: &#123; clickOk: function() &#123; alert(\"I am OK\"); &#125; &#125;&#125;);setTimeout(function() &#123; myvm.data.name = \"wawawa...vue was born\";&#125;, 2000);&lt;/script&gt; 5、其他5.1 proxy代理data可能注意到了，我们不管是在赋值还是取值，都是在myvm.data.someAttr上操作的，而在vue上我们习惯直接myvm.someAttr这种形式。怎样实现呢？同样，我们可以用Object.defineProperty对data所有属性做一个代理，即访问vue实例属性时，代理到data上。很简单，实现如下： 1234567891011121314151617/** * 将数据拓展到vue的根，方便读取和设置 */MyVue.prototype.proxy = function(key) &#123; var self = this; Object.defineProperty(this, key, &#123; enumerable: true, configurable: true, get: function proxyGetter() &#123; return self.data[key]; &#125;, set: function proxySetter(newVal) &#123; self.data[key] = newVal; &#125; &#125;);&#125; 5.2 parsePath上面对于data的操作只是到对于简单的基本类型属性，对于对象属性的改变该怎么更新到位呢？其实，只要深度遍历对象属性路径，就可以找到要访问属性值。 12345678910111213141516171819/** * 根据对象属性路径，最终获取值 * @param &#123;Object&#125; obj 对象 * @param &#123;String&#125; path 路径 * return 值 */function parsePath(obj, path) &#123; var bailRE = /[^\\w.$]/; if (bailRE.test(path)) &#123; return &#125; var segments = path.split('.'); for (var i = 0; i &lt; segments.length; i++) &#123; if (!obj) &#123; return &#125; obj = obj[segments[i]]; &#125; return obj;&#125; 用这个方法替换我们的所有取值操作vm[exp] =&gt; parsePath(vm, exp) 6、新增属性的双向数据绑定6.1 给对象添加属性Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。也就是我们需要在Vue原型上添加一个set方法去设置新添加的属性，新属性同样要进行监听和添加订阅者。 123456789101112131415161718192021222324252627282930313233/** * vue的set方法，用于外部新增属性 Vue.$set(target, key, val) * @param &#123;Object&#125; target 数据 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; val 值 */function set(target, key, val) &#123; if (Array.isArray(target)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val; &#125; if (target.hasOwnProperty(key)) &#123; target[key] = val; return val &#125; var ob = (target).$Observer; if (!ob) &#123; target[key] = val; return val &#125; // 对新增属性定义监听 ob.defineReactive(target, key, val); ob.dep.notify(); return val;&#125;MyVue.prototype.$set = set; 6.1 给数组对象添加属性把数组看成一个特殊的对象，就很容易理解了，对于unshift、push和splice变异方法是添加了对象的属性的，需要对新加的属性进行监听和添加订阅者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var arrKeys = [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\", \"sort\", \"reverse\"];var extendArr = [];arrKeys.forEach(function(key) &#123; def(extendArr, key, function() &#123; var result, arrProto = Array.prototype, ob = this.$Observer, arr = arrProto.slice.call(arguments), inserted, index; switch (key) &#123; case \"push\": inserted = arr; index = this.length; break; case \"unshift\": inserted = arr; index = 0; break; case \"splice\": inserted = arr.slice(2); index = arr[0]; break; &#125; result = arrProto[key].apply(this, arguments); // 监听新增数组对象属性 if (inserted) &#123; ob.observeArray(inserted); &#125; ob.dep.notify(); return result; &#125;);&#125;);var arrayKeys = Object.getOwnPropertyNames(extendArr);/** * 监听器构造函数 * @param &#123;Object&#125; data 被监听数据 */function Observer(data) &#123; this.dep = new Dep(); if (!data || typeof data !== \"object\") &#123; return; &#125; // 在每个object上添加一个observer def(data, \"$Observer\", this); // 继承变异方法 if (Array.isArray(data)) &#123; // 把数组变异方法的处理，添加到原型链上 data.__proto__ = extendArr; // 监听数组对象属性 this.observeArray(data); &#125; else &#123; this.data = data; this.walk(data); &#125;&#125;Observer.prototype = &#123; // ... /** * 监听数组 */ observeArray: function(items) &#123; console.log(\"items:\", items); for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]); &#125; &#125;&#125;;","categories":[{"name":"vue","slug":"vue","permalink":"https://leekiwi.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://leekiwi.github.io/tags/vue/"}]},{"title":"vue-cli中遇到的坑","slug":"vue-cli中遇到的坑","date":"2017-09-02T01:00:30.000Z","updated":"2018-09-10T09:49:01.318Z","comments":true,"path":"2017/09/02/vue-cli中遇到的坑/","link":"","permalink":"https://leekiwi.github.io/2017/09/02/vue-cli中遇到的坑/","excerpt":"Vue-cli 脚手架项目构建自动化，错误查起来越来越不知所措，坑很多，踩过后要记录，防止踩第二遍 vue 单文件@import css 文件，不加~会报错","text":"Vue-cli 脚手架项目构建自动化，错误查起来越来越不知所措，坑很多，踩过后要记录，防止踩第二遍 vue 单文件@import css 文件，不加~会报错 123&lt;style lang=&quot;stylus&quot; scoped&gt;@import &apos;assets/css/variable&apos;&lt;/style&gt; 报错： 12345678910[HMR] bundle has 1 errors172:176 ./~/css-loader?&#123;&quot;minimize&quot;:false,&quot;sourceMap&quot;:false&#125;!./~/vue-loader/lib/style-compiler?&#123;&quot;vue&quot;:true,&quot;id&quot;:&quot;data-v-be4708e4&quot;,&quot;scoped&quot;:true,&quot;hasInlineConfig&quot;:false&#125;!./~/stylus-loader?&#123;&quot;sourceMap&quot;:false&#125;!./~/vue-loader/lib/selector.js?type=styles&amp;index=0!./src/components/views/programs/Programs.vueModule build failed: Error: D:\\appSoft\\wampserver\\wamp64\\www\\iHomed_vue\\src\\components\\views\\programs\\Programs.vue:200:9 196| &#125; 197| &lt;/script&gt; 198| 199| &lt;style lang=&quot;stylus&quot; scoped&gt; 200| @import &apos;assets/css/variable&apos;----------------^ 201| 正确写法@import &#39;~assets/css/variable&#39; vue-cli 中 config/index.js 配置说明1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; build: &#123; env: require(&apos;./prod.env&apos;), // 使用 config/prod.env.js 中定义的编译环境 index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件 assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 编译输出的静态资源路径 assetsSubDirectory: &apos;static&apos;, // 编译输出的二级目录 assetsPublicPath: &apos;/&apos;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 productionSourceMap: true, // 是否开启 cssSourceMap // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, // 是否开启 gzip productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // 需要使用 gzip 压缩的文件扩展名 // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;, dev: &#123; // dev 环境 env: require(&apos;./dev.env&apos;), // 使用 config/dev.env.js 中定义的编译环境 port: 8084, // 运行测试页面的端口 autoOpenBrowser: true, // 自动在浏览器中打开 assetsSubDirectory: &apos;static&apos;, // 编译输出的二级目录 assetsPublicPath: &apos;/&apos;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 proxyTable: &#123;&#125;, // 需要 proxyTable 代理的接口（可跨域） // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false // 是否开启 cssSourceMap &#125;&#125; 曾经不易理解的两点assetsSubDirectory和assetsPublicPath assetsSubDirectory被 webpack 编译处理过的资源文件都会在这个 build.assetsRoot 目录下，如果 assetsRoot 值是&quot;/web/app&quot;，assetsSubDirectory 值为&quot;static&quot;，那么，webpack 将把所有资源编译到web/app/static目录下 assetsPublicPath这个是通过 http 服务器运行的 url 路径，大多数情况下，这个是根目录（/）。如果你的后台框架对静态资源 url 前缀有要求，你仅需改变这个参数。比如不用本地的，而用线上的 CDN。 父子组件嵌套，各个钩子函数触发顺序偶然看到这个问题：vue 中父子组件各个钩子函数触发顺序是怎样的？一时还真背问到了，在项目中添加打印才发现是这样子的 顺序是：先依次触发父级组件beforeCreate、create和beforeMounte，再依次触发子级组件beforeCreate、create、beforeMounte和mounted，最后父级组件mounted 父子组件之间通信，兄弟组件之间通信这个问题基本清晰，在这归纳一下 1. 父组件数据传给子组件通过props属性传递 12&lt;!--父组件--&gt;&lt;parent-component :parent-data=\"pdata\"&gt;&lt;/parent-component&gt; 123456789// 子组件export default &#123; props: &#123; parentData: &#123; type: String, default: '' &#125; &#125;&#125; 2. 子组件传数据给父组件使用$emit派发 12&lt;!--父组件--&gt;&lt;parent-component :parent-data:sync=\"pdata\" @handle-callback=\"handlerCallback\"&gt;&lt;/parent-component&gt; 12345678// 父组件export default &#123; methods: &#123; handlerCallback(params) &#123; // do something &#125; &#125;&#125; 12345678910// 子组件export default &#123; created() &#123; // ... this.$emit('handleCallback', params) // ... this.$emit('update:parentData', someData) &#125;&#125; 3. 兄弟组件数据传递 对于大型项目，用 vue 官方推荐的 vuex EventBus 提取 bus.js 123import Vue from 'vue'const bus = new Vue()export default bus 兄弟组件 1 发送数据 12345678import bus from './bus'export default &#123; created() &#123; // ... this.$emit('busEvent1', someData) &#125;&#125; 兄弟组件 2 接收数据 12345678910import bus from './bus'export default &#123; created() &#123; // ... this.$on('busEvent1', function(data) &#123; console.log(data) &#125;) &#125;&#125; 子组件 A $emit派发某个事件，再由父组件@handle-callback=&quot;handlerCallback&quot;监听获取数据，然后，父组件$refs直接访问到子组件 B 的方法，从而间接实现从子组件 A 到子组件 B 的数据传递 props 在子组件中被重写报错1vue.esm.js?06e7:591 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"isShow\" 解决方案props传过来的参数通过Vue.$emit提交修改 在props和data中使用this在 Vue2.2.2 或更高版本才能这样使用，低于这个版本时，注入的值会在props和data初始化之后得到。 对于高阶插件/组件库，解决组件与其子孙组件数据传输问题 解决方案一：$attrs和$listener 使用属性和方法不通过props传递，在子孙组件中直接用$attrs和$listeners接收。不过支持 v2.4.0+。 1234567891011121314151617181920// 父级组件&lt;ul id=\"app6\"&gt; &lt;item class=\"item\" :model=\"treeData\" :count=\"123\" @abc=\"function()&#123;&#125;\" &gt;&lt;/item&gt;&lt;/ul&gt;// 子孙组件inheritAttrs: false,created () &#123; let attrs = this.$attrs; console.log('mode:', attrs.mode); console.log('count:', attrs.count); let listeners = this.$listeners; console.log('bac:', listeners.abc);&#125; 解决方案二：provide/inject 父级组件传入provide数据选项，子孙组件注入inject数据。 1234567// 父组件provide: &#123; foo: 'bar'&#125;// 子孙组件inject: ['foo'] // or inject: &#123; name: 'foo', defult: '' &#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://leekiwi.github.io/categories/vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://leekiwi.github.io/tags/vue-cli/"}]}]}